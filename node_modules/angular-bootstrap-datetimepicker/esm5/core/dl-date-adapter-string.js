/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Inject } from '@angular/core';
import * as _moment from 'moment';
import { DlDateAdapter } from './dl-date-adapter';
import { DL_DATE_TIME_INPUT_FORMATS, DL_DATE_TIME_MODEL_FORMAT } from './dl-date-time-string-format';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 *
 * @type {?}
 */
var moment = _moment;
/**
 * Adapts `string` to be usable as a date by date/time components that work with dates.
 *
 */
var DlDateAdapterString = /** @class */ (function (_super) {
    tslib_1.__extends(DlDateAdapterString, _super);
    /**
     *  Constructs a new instance of this class.
     *
     * @param inputFormats
     *  see {@link DL_DATE_TIME_INPUT_FORMATS}
     * @param modelFormat
     *  see {@link DL_DATE_TIME_MODEL_FORMAT}
     */
    function DlDateAdapterString(inputFormats, modelFormat) {
        var _this = _super.call(this) || this;
        _this.inputFormats = inputFormats;
        _this.modelFormat = modelFormat;
        return _this;
    }
    /**
     * Returns the specified number.
     * @param milliseconds
     *  a moment time time.
     * @returns
     *  the specified moment in time.
     */
    /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    DlDateAdapterString.prototype.fromMilliseconds = /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    function (milliseconds) {
        return moment(milliseconds).format(this.modelFormat);
    };
    /**
     * Returns the specified number.
     * @param value
     *  a moment time time or `null`
     * @returns
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    DlDateAdapterString.prototype.toMilliseconds = /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    function (value) {
        if (value !== undefined && value !== null) {
            /** @type {?} */
            var newMoment = moment(value, this.inputFormats, true);
            return newMoment.isValid() ? newMoment.valueOf() : undefined;
        }
    };
    /** @nocollapse */
    DlDateAdapterString.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_MODEL_FORMAT,] }] }
    ]; };
    return DlDateAdapterString;
}(DlDateAdapter));
export { DlDateAdapterString };
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateAdapterString.prototype.inputFormats;
    /**
     * @type {?}
     * @private
     */
    DlDateAdapterString.prototype.modelFormat;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS1hZGFwdGVyLXN0cmluZy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiY29yZS9kbC1kYXRlLWFkYXB0ZXItc3RyaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNyQyxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDaEQsT0FBTyxFQUFDLDBCQUEwQixFQUFFLHlCQUF5QixFQUFDLE1BQU0sOEJBQThCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBZ0I3RixNQUFNLEdBQUcsT0FBTzs7Ozs7QUFLdEI7SUFBeUMsK0NBQXFCO0lBSzVEOzs7Ozs7O09BT0c7SUFDSCw2QkFBZ0QsWUFBc0IsRUFDdkIsV0FBbUI7UUFEbEUsWUFFRSxpQkFBTyxTQUdSO1FBRkMsS0FBSSxDQUFDLFlBQVksR0FBRyxZQUFZLENBQUM7UUFDakMsS0FBSSxDQUFDLFdBQVcsR0FBRyxXQUFXLENBQUM7O0lBQ2pDLENBQUM7SUFFRDs7Ozs7O09BTUc7Ozs7Ozs7O0lBQ0gsOENBQWdCOzs7Ozs7O0lBQWhCLFVBQWlCLFlBQW9CO1FBQ25DLE9BQU8sTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7SUFDdkQsQ0FBQztJQUVEOzs7Ozs7O09BT0c7Ozs7Ozs7OztJQUNILDRDQUFjOzs7Ozs7OztJQUFkLFVBQWUsS0FBb0I7UUFDakMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7O2dCQUNuQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQztZQUN4RCxPQUFPLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDOUQ7SUFDSCxDQUFDOzs7NENBL0JZLE1BQU0sU0FBQywwQkFBMEI7NkNBQ2pDLE1BQU0sU0FBQyx5QkFBeUI7O0lBK0IvQywwQkFBQztDQUFBLEFBN0NELENBQXlDLGFBQWEsR0E2Q3JEO1NBN0NZLG1CQUFtQjs7Ozs7O0lBRTlCLDJDQUF3Qzs7Ozs7SUFDeEMsMENBQXFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtEbERhdGVBZGFwdGVyfSBmcm9tICcuL2RsLWRhdGUtYWRhcHRlcic7XG5pbXBvcnQge0RMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTLCBETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUfSBmcm9tICcuL2RsLWRhdGUtdGltZS1zdHJpbmctZm9ybWF0JztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogQWRhcHRzIGBzdHJpbmdgIHRvIGJlIHVzYWJsZSBhcyBhIGRhdGUgYnkgZGF0ZS90aW1lIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuXG4gKiovXG5leHBvcnQgY2xhc3MgRGxEYXRlQWRhcHRlclN0cmluZyBleHRlbmRzIERsRGF0ZUFkYXB0ZXI8c3RyaW5nPiB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpbnB1dEZvcm1hdHM6IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vZGVsRm9ybWF0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dEZvcm1hdHNcbiAgICogIHNlZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9XG4gICAqIEBwYXJhbSBtb2RlbEZvcm1hdFxuICAgKiAgc2VlIHtAbGluayBETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUfVxuICAgKi9cbiAgY29uc3RydWN0b3IoQEluamVjdChETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUykgaW5wdXRGb3JtYXRzOiBzdHJpbmdbXSxcbiAgICAgICAgICAgICAgQEluamVjdChETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUKSBtb2RlbEZvcm1hdDogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlucHV0Rm9ybWF0cyA9IGlucHV0Rm9ybWF0cztcbiAgICB0aGlzLm1vZGVsRm9ybWF0ID0gbW9kZWxGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAgICogQHBhcmFtIG1pbGxpc2Vjb25kc1xuICAgKiAgYSBtb21lbnQgdGltZSB0aW1lLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGZyb21NaWxsaXNlY29uZHMobWlsbGlzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb21lbnQobWlsbGlzZWNvbmRzKS5mb3JtYXQodGhpcy5tb2RlbEZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqICBhIG1vbWVudCB0aW1lIHRpbWUgb3IgYG51bGxgXG4gICAqIEByZXR1cm5zXG4gICAqICB0aGUgbWlsbGlzZWNvbmRzIGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlIG9yIGBudWxsYFxuICAgKiAgYG51bGxgIGlzIHJldHVybmVkIHdoZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQgaW5wdXQgZGF0ZSBzdHJpbmdcbiAgICovXG4gIHRvTWlsbGlzZWNvbmRzKHZhbHVlOiBzdHJpbmcgfCBudWxsKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5ld01vbWVudCA9IG1vbWVudCh2YWx1ZSwgdGhpcy5pbnB1dEZvcm1hdHMsIHRydWUpO1xuICAgICAgcmV0dXJuIG5ld01vbWVudC5pc1ZhbGlkKCkgPyBuZXdNb21lbnQudmFsdWVPZigpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIl19