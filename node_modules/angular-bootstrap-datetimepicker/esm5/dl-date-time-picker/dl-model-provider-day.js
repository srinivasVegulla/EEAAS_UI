/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment = _moment;
/**
 * Default implementation for the `day` view.
 */
var /**
 * Default implementation for the `day` view.
 */
DlDayModelProvider = /** @class */ (function () {
    function DlDayModelProvider() {
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlDayModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param milliseconds
     *  the moment in time from which the minute model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlDayModelProvider.prototype.getModel = /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var startOfMonth = moment(milliseconds).startOf('month');
        /** @type {?} */
        var endOfMonth = moment(milliseconds).endOf('month');
        /** @type {?} */
        var startOfView = moment(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
        /** @type {?} */
        var rowNumbers = [0, 1, 2, 3, 4, 5];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3, 4, 5, 6];
        /** @type {?} */
        var previousMonth = moment(startOfMonth).subtract(1, 'month');
        /** @type {?} */
        var nextMonth = moment(startOfMonth).add(1, 'month');
        /** @type {?} */
        var activeValue = moment(milliseconds).startOf('day').valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(selectedMilliseconds).startOf('day').valueOf();
        return {
            viewName: 'day',
            viewLabel: startOfMonth.format('MMM YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousMonth.valueOf(),
                ariaLabel: "Go to " + previousMonth.format('MMM YYYY'),
                classes: {},
            },
            upButton: {
                value: startOfMonth.valueOf(),
                ariaLabel: "Go to month view",
                classes: {},
            },
            rightButton: {
                value: nextMonth.valueOf(),
                ariaLabel: "Go to " + nextMonth.format('MMM YYYY'),
                classes: {},
            },
            rowLabels: columnNumbers.map((/**
             * @param {?} column
             * @return {?}
             */
            function (column) { return moment().weekday(column).format('dd'); })),
            rows: rowNumbers.map(rowOfDays)
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfDays(rowNumber) {
            /** @type {?} */
            var currentMoment = moment();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var dayMoment = moment(startOfView).add((rowNumber * columnNumbers.length) + columnNumber, 'days');
                return {
                    display: dayMoment.format('D'),
                    ariaLabel: dayMoment.format('ll'),
                    value: dayMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === dayMoment.valueOf(),
                        'dl-abdtp-future': dayMoment.isAfter(endOfMonth),
                        'dl-abdtp-past': dayMoment.isBefore(startOfMonth),
                        'dl-abdtp-selected': selectedValue === dayMoment.valueOf(),
                        'dl-abdtp-now': dayMoment.isSame(currentMoment, 'day'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    DlDayModelProvider.prototype.goDown = /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(7, 'days').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    DlDayModelProvider.prototype.goUp = /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(7, 'days').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    DlDayModelProvider.prototype.goLeft = /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    DlDayModelProvider.prototype.goRight = /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    DlDayModelProvider.prototype.pageDown = /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    DlDayModelProvider.prototype.pageUp = /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the last cell in the view as the active `day`.
     */
    /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `day`.
     */
    DlDayModelProvider.prototype.goEnd = /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `day`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds)
            .endOf('month').startOf('day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the first cell in the view as the active `day`.
     */
    /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `day`.
     */
    DlDayModelProvider.prototype.goHome = /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `day`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).startOf('month').valueOf(), selectedMilliseconds);
    };
    return DlDayModelProvider;
}());
/**
 * Default implementation for the `day` view.
 */
export { DlDayModelProvider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXItZGF5LmpzIiwic291cmNlUm9vdCI6Im5nOi8vYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvIiwic291cmNlcyI6WyJkbC1kYXRlLXRpbWUtcGlja2VyL2RsLW1vZGVsLXByb3ZpZGVyLWRheS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFVQSxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztJQWlCNUIsTUFBTSxHQUFHLE9BQU87Ozs7QUFLdEI7Ozs7SUFBQTtJQXdPQSxDQUFDO0lBdE9DOzs7OztPQUtHOzs7Ozs7OztJQUNILHNDQUFTOzs7Ozs7O0lBQVQsVUFBVSxPQUFzQjtJQUNoQyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7O09BaUJHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQ0gscUNBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7OztJQUFSLFVBQVMsWUFBb0IsRUFBRSxvQkFBNEI7O1lBRW5ELFlBQVksR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQzs7WUFDcEQsVUFBVSxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDOztZQUNoRCxXQUFXLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLFlBQVksQ0FBQyxPQUFPLEVBQUUsQ0FBQyxFQUFFLE1BQU0sQ0FBQzs7WUFFckYsVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7O1lBQy9CLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQzs7WUFFckMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxZ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aWdodCAyMDEzLXByZXNlbnQgRGFsZSBMb3R0cyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICogaHR0cDovL3d3dy5kYWxlbG90dHMuY29tXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9naXRodWIuY29tL2RhbGVsb3R0cy9hbmd1bGFyLWJvb3RzdHJhcC1kYXRldGltZXBpY2tlci9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHtTaW1wbGVDaGFuZ2VzfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCAqIGFzIF9tb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7RGxEYXRlVGltZVBpY2tlck1vZGVsfSBmcm9tICcuL2RsLWRhdGUtdGltZS1waWNrZXItbW9kZWwnO1xuaW1wb3J0IHtEbE1vZGVsUHJvdmlkZXJ9IGZyb20gJy4vZGwtbW9kZWwtcHJvdmlkZXInO1xuXG4vKipcbiAqIFdvcmsgYXJvdW5kIGZvciBtb21lbnQgbmFtZXNwYWNlIGNvbmZsaWN0IHdoZW4gdXNlZCB3aXRoIHdlYnBhY2sgYW5kIHJvbGx1cC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZGhlcmdlcy9uZy1wYWNrYWdyL2lzc3Vlcy8xNjNcbiAqXG4gKiBEZXBlbmRpbmcgb24gd2hldGhlciByb2xsdXAgaXMgdXNlZCwgbW9tZW50IG5lZWRzIHRvIGJlIGltcG9ydGVkIGRpZmZlcmVudGx5LlxuICogU2luY2UgTW9tZW50LmpzIGRvZXNuJ3QgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0LCB3ZSBub3JtYWxseSBuZWVkIHRvIGltcG9ydCB1c2luZ1xuICogdGhlIGAqIGFzYHN5bnRheC5cbiAqXG4gKiByb2xsdXAgY3JlYXRlcyBhIHN5bnRoZXRpYyBkZWZhdWx0IG1vZHVsZSBhbmQgd2UgdGh1cyBuZWVkIHRvIGltcG9ydCBpdCB1c2luZ1xuICogdGhlIGBkZWZhdWx0IGFzYCBzeW50YXguXG4gKlxuICogQGludGVybmFsXG4gKiovXG5jb25zdCBtb21lbnQgPSBfbW9tZW50O1xuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBgZGF5YCB2aWV3LlxuICovXG5leHBvcnQgY2xhc3MgRGxEYXlNb2RlbFByb3ZpZGVyIGltcGxlbWVudHMgRGxNb2RlbFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogUmVjZWl2ZXMgaW5wdXQgY2hhbmdlcyBkZXRlY3RlZCBieSBBbmd1bGFyLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbmdlc1xuICAgKiAgdGhlIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICovXG4gIG9uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYGRheWAgbW9kZWwgZm9yIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIGBsb2NhbGAgdGltZSB3aXRoIHRoZVxuICAgKiBgYWN0aXZlYCBkYXkgc2V0IHRvIHRoZSBmaXJzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGUgYGRheWAgbW9kZWwgcmVwcmVzZW50cyBhIG1vbnRoICg0MiBkYXlzKSBhcyBzaXggcm93cyB3aXRoIHNldmVuIGNvbHVtbnNcbiAgICogYW5kIGVhY2ggY2VsbCByZXByZXNlbnRpbmcgb25lLWRheSBpbmNyZW1lbnRzLlxuICAgKlxuICAgKiBUaGUgYGRheWAgYWx3YXlzIHN0YXJ0cyBhdCBtaWRuaWdodC5cbiAgICpcbiAgICogRWFjaCBjZWxsIHJlcHJlc2VudHMgYSBvbmUtZGF5IGluY3JlbWVudCBhdCBtaWRuaWdodC5cbiAgICpcbiAgICogQHBhcmFtIG1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG1pbnV0ZSBtb2RlbCB3aWxsIGJlIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICB0aGUgbW9kZWwgcmVwcmVzZW50aW5nIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnZXRNb2RlbChtaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG5cbiAgICBjb25zdCBzdGFydE9mTW9udGggPSBtb21lbnQobWlsbGlzZWNvbmRzKS5zdGFydE9mKCdtb250aCcpO1xuICAgIGNvbnN0IGVuZE9mTW9udGggPSBtb21lbnQobWlsbGlzZWNvbmRzKS5lbmRPZignbW9udGgnKTtcbiAgICBjb25zdCBzdGFydE9mVmlldyA9IG1vbWVudChzdGFydE9mTW9udGgpLnN1YnRyYWN0KE1hdGguYWJzKHN0YXJ0T2ZNb250aC53ZWVrZGF5KCkpLCAnZGF5cycpO1xuXG4gICAgY29uc3Qgcm93TnVtYmVycyA9IFswLCAxLCAyLCAzLCA0LCA1XTtcbiAgICBjb25zdCBjb2x1bW5OdW1iZXJzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDZdO1xuXG4gICAgY29uc3QgcHJldmlvdXNNb250aCA9IG1vbWVudChzdGFydE9mTW9udGgpLnN1YnRyYWN0KDEsICdtb250aCcpO1xuICAgIGNvbnN0IG5leHRNb250aCA9IG1vbWVudChzdGFydE9mTW9udGgpLmFkZCgxLCAnbW9udGgnKTtcbiAgICBjb25zdCBhY3RpdmVWYWx1ZSA9IG1vbWVudChtaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IG51bGwgfHwgc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IHVuZGVmaW5lZFxuICAgICAgPyBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAgOiBtb21lbnQoc2VsZWN0ZWRNaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKTtcblxuICAgIHJldHVybiB7XG4gICAgICB2aWV3TmFtZTogJ2RheScsXG4gICAgICB2aWV3TGFiZWw6IHN0YXJ0T2ZNb250aC5mb3JtYXQoJ01NTSBZWVlZJyksXG4gICAgICBhY3RpdmVEYXRlOiBhY3RpdmVWYWx1ZSxcbiAgICAgIGxlZnRCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IHByZXZpb3VzTW9udGgudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke3ByZXZpb3VzTW9udGguZm9ybWF0KCdNTU0gWVlZWScpfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHVwQnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBzdGFydE9mTW9udGgudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byBtb250aCB2aWV3YCxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICB9LFxuICAgICAgcmlnaHRCdXR0b246IHtcbiAgICAgICAgdmFsdWU6IG5leHRNb250aC52YWx1ZU9mKCksXG4gICAgICAgIGFyaWFMYWJlbDogYEdvIHRvICR7bmV4dE1vbnRoLmZvcm1hdCgnTU1NIFlZWVknKX1gLFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIH0sXG4gICAgICByb3dMYWJlbHM6IGNvbHVtbk51bWJlcnMubWFwKChjb2x1bW4pID0+IG1vbWVudCgpLndlZWtkYXkoY29sdW1uKS5mb3JtYXQoJ2RkJykpLFxuICAgICAgcm93czogcm93TnVtYmVycy5tYXAocm93T2ZEYXlzKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByb3dPZkRheXMocm93TnVtYmVyKSB7XG4gICAgICBjb25zdCBjdXJyZW50TW9tZW50ID0gbW9tZW50KCk7XG4gICAgICBjb25zdCBjZWxscyA9IGNvbHVtbk51bWJlcnMubWFwKChjb2x1bW5OdW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgZGF5TW9tZW50ID0gbW9tZW50KHN0YXJ0T2ZWaWV3KS5hZGQoKHJvd051bWJlciAqIGNvbHVtbk51bWJlcnMubGVuZ3RoKSArIGNvbHVtbk51bWJlciwgJ2RheXMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwbGF5OiBkYXlNb21lbnQuZm9ybWF0KCdEJyksXG4gICAgICAgICAgYXJpYUxhYmVsOiBkYXlNb21lbnQuZm9ybWF0KCdsbCcpLFxuICAgICAgICAgIHZhbHVlOiBkYXlNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgICAgICdkbC1hYmR0cC1hY3RpdmUnOiBhY3RpdmVWYWx1ZSA9PT0gZGF5TW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICdkbC1hYmR0cC1mdXR1cmUnOiBkYXlNb21lbnQuaXNBZnRlcihlbmRPZk1vbnRoKSxcbiAgICAgICAgICAgICdkbC1hYmR0cC1wYXN0JzogZGF5TW9tZW50LmlzQmVmb3JlKHN0YXJ0T2ZNb250aCksXG4gICAgICAgICAgICAnZGwtYWJkdHAtc2VsZWN0ZWQnOiBzZWxlY3RlZFZhbHVlID09PSBkYXlNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgICAgJ2RsLWFiZHRwLW5vdyc6IGRheU1vbWVudC5pc1NhbWUoY3VycmVudE1vbWVudCwgJ2RheScpLFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtjZWxsc307XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgZGF5YCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIE1vdmluZyBgZG93bmAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgZGF5IGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgbW9udGggdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBtb250aCByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBob3VyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGRheWAgbW9kZWwgYGRvd25gIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBkYXlgIG9uZSByb3cgYGRvd25gIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvRG93bihmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQoNywgJ2RheXMnKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYGRheWAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogTW92aW5nIGB1cGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgZGF5IGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgbW9udGggdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBtb250aCByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBob3VyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGRheWAgbW9kZWwgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgZGF5YCBvbmUgcm93IGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29VcChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdWJ0cmFjdCg3LCAnZGF5cycpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGRheSBvbmUgY2VsbCBgbGVmdGAgaW4gdGhlIGN1cnJlbnQgYGRheWAgdmlldy5cbiAgICpcbiAgICogTW92aW5nIGBsZWZ0YCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBkYXkgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBtb250aCB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIG1vbnRoIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgYGRheWAgbW9kZWwgdG8gdGhlIGBsZWZ0YCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgZGF5YCBvbmUgY2VsbCB0byB0aGUgYGxlZnRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb0xlZnQoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoMSwgJ2RheScpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGRheSBvbmUgY2VsbCBgcmlnaHRgIGluIHRoZSBjdXJyZW50IGBkYXlgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgcmlnaHRgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGRheSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IG1vbnRoIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgbW9udGggcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgeWVhci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgZGF5YCBtb2RlbCB0byB0aGUgYHJpZ2h0YCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgZGF5YCBvbmUgY2VsbCB0byB0aGUgYHJpZ2h0YCBvZiB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29SaWdodChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQoMSwgJ2RheScpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgZGF5YCBvbmUgbW9udGggYGRvd25gIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogUGFnaW5nIGBkb3duYCB3aWxsIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgZGF5IGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgbW9udGggdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYC4gQXMgYSByZXN1bHQsIHRoZSBtb250aCByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCB5ZWFyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGRheWAgbW9kZWwgcGFnZSBgZG93bmAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGRheWAgb25lIG1vbnRoIGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBwYWdlRG93bihmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQoMSwgJ21vbnRoJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGBkYXlgIG9uZSBtb250aCBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogUGFnaW5nIGB1cGAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGRheSBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IG1vbnRoIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgbW9udGggcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgeWVhci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBuZXh0IGBkYXlgIG1vZGVsIHBhZ2UgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgZGF5YCBvbmUgbW9udGggYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBwYWdlVXAoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoMSwgJ21vbnRoJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgZGF5YCB0byB0aGUgbGFzdCBkYXkgb2YgdGhlIG1vbnRoLlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBkYXkgdGhhbiB0aGUgZGlzcGxheWVkIGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBsYXN0IGRheSBvZiB0aGUgbW9udGggd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBsYXN0IGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgZGF5YC5cbiAgICovXG4gIGdvRW5kKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpXG4gICAgICAuZW5kT2YoJ21vbnRoJykuc3RhcnRPZignZGF5JykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYGRheWAgdG8gdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGguXG4gICAqXG4gICAqIFRoZSB2aWV3IG9yIHRpbWUgcmFuZ2Ugd2lsbCBub3QgY2hhbmdlIHVubGVzcyB0aGUgYGZyb21NaWxsaXNlY29uZHNgIHZhbHVlXG4gICAqIGlzIGluIGEgZGlmZmVyZW50IGRheSB0aGFuIHRoZSBkaXNwbGF5ZWQgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGZpcnN0IGRheSBvZiB0aGUgbW9udGggd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBmaXJzdCBjZWxsIGluIHRoZSB2aWV3IGFzIHRoZSBhY3RpdmUgYGRheWAuXG4gICAqL1xuICBnb0hvbWUoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3RhcnRPZignbW9udGgnKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxufVxuIl19