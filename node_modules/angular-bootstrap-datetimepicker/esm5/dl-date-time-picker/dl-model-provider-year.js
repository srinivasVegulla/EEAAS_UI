/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment = _moment;
/**
 * Default implementation for the `year` view.
 */
var /**
 * Default implementation for the `year` view.
 */
DlYearModelProvider = /** @class */ (function () {
    function DlYearModelProvider() {
    }
    /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * @param fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @returns
     *  moment at midnight january 1 at the start of the current decade.
     * @internal
     */
    /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * \@internal
     * @private
     * @param {?} fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @return {?}
     *  moment at midnight january 1 at the start of the current decade.
     */
    DlYearModelProvider.getStartOfDecade = /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * \@internal
     * @private
     * @param {?} fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @return {?}
     *  moment at midnight january 1 at the start of the current decade.
     */
    function (fromMilliseconds) {
        // Truncate the last digit from the current year to get the start of the decade
        /** @type {?} */
        var startDecade = (Math.trunc(moment(fromMilliseconds).year() / 10) * 10);
        return moment({ year: startDecade }).startOf('year');
    };
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlYearModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param milliseconds
     *  the moment in time from which the year model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the year model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlYearModelProvider.prototype.getModel = /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the year model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var rowNumbers = [0, 1];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3, 4];
        /** @type {?} */
        var startYear = moment(milliseconds).startOf('year');
        /** @type {?} */
        var startDate = DlYearModelProvider.getStartOfDecade(milliseconds);
        /** @type {?} */
        var futureYear = startDate.year() + 9;
        /** @type {?} */
        var pastYear = startDate.year();
        /** @type {?} */
        var activeValue = startYear.valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(selectedMilliseconds).startOf('year').valueOf();
        return {
            viewName: 'year',
            viewLabel: pastYear + "-" + futureYear,
            activeDate: activeValue,
            leftButton: {
                value: moment(startDate).subtract(10, 'years').valueOf(),
                ariaLabel: "Go to " + (pastYear - 10) + "-" + (pastYear - 1),
                classes: {},
            },
            rightButton: {
                value: moment(startDate).add(10, 'years').valueOf(),
                ariaLabel: "Go to " + (futureYear + 1) + "-" + (futureYear + 10),
                classes: {},
            },
            rows: rowNumbers.map(rowOfYears.bind(this))
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfYears(rowNumber) {
            /** @type {?} */
            var currentMoment = moment();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var yearMoment = moment(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'years');
                return {
                    display: yearMoment.format('YYYY'),
                    value: yearMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === yearMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === yearMoment.valueOf(),
                        'dl-abdtp-now': yearMoment.isSame(currentMoment, 'year'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    DlYearModelProvider.prototype.goDown = /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(5, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    DlYearModelProvider.prototype.goUp = /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(5, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    DlYearModelProvider.prototype.goLeft = /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    DlYearModelProvider.prototype.goRight = /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    DlYearModelProvider.prototype.pageDown = /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(10, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    DlYearModelProvider.prototype.pageUp = /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(10, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `last` cell in the view as the active `year`.
     */
    /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `last` cell in the view as the active `year`.
     */
    DlYearModelProvider.prototype.goEnd = /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `last` cell in the view as the active `year`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .add(9, 'years')
            .endOf('year')
            .valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `first` cell in the view as the active `year`.
     */
    /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `first` cell in the view as the active `year`.
     */
    DlYearModelProvider.prototype.goHome = /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `first` cell in the view as the active `year`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .startOf('year')
            .valueOf(), selectedMilliseconds);
    };
    return DlYearModelProvider;
}());
/**
 * Default implementation for the `year` view.
 */
export { DlYearModelProvider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXIteWVhci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLXBpY2tlci9kbC1tb2RlbC1wcm92aWRlci15ZWFyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQVVBLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDOzs7Ozs7Ozs7Ozs7Ozs7O0lBa0I1QixNQUFNLEdBQUcsT0FBTzs7OztBQUt0Qjs7OztJQUFBO0lBMFFBLENBQUM7SUF4UUM7Ozs7Ozs7OztPQVNHOzs7Ozs7Ozs7Ozs7SUFDWSxvQ0FBZ0I7Ozs7Ozs7Ozs7O0lBQS9CLFVBQWdDLGdCQUF3Qjs7O1lBRWhELFdBQVcsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLGdCQUFnQixDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxDQUFDO1FBQzNFLE9BQU8sTUFBTSxDQUFDLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBQyxDQUFDLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFFRDs7Ozs7T0FLRzs7Ozs7Ozs7SUFDSCx1Q0FBUzs7Ozs7OztJQUFULFVBQVUsT0FBc0I7SUFDaEMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7T0FrQkc7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBQ0gsc0NBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7SUFBUixVQUFTLFlBQW9CLEVBQUUsb0JBQTRCOztZQUNuRCxVQUFVLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDOztZQUNuQixhQUFhLEdBQUcsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxDQUFDOztZQUUvQixTQUFTLEdBQUcsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE9BQU8s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Ozs7Ozs7Ozs7O0lBQU4sVUFBTyxnQkFBd0IsRUFBRSxvQkFBNEI7UUFDM0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsTUFBTSxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUUsb0JBQW9CLENBQUMsQ0FBQztJQUN0RyxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7OztPQVlHOzs7Ozs7Ozs7Ozs7OztJQUNILG1DQUFLOzs7Ozs7Ozs7Ozs7O0lBQUwsVUFBTSxnQkFBd0IsRUFBRSxvQkFBNEI7UUFDMUQsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUNsQixtQkFBbUIsQ0FBQyxnQkFBZ0IsQ0FBQyxnQkFBZ0IsQ0FBQzthQUNuRCxHQUFHLENBQUMsQ0FBQyxFQUFFLE9BQU8sQ0FBQzthQUNmLEtBQUssQ0FBQyxNQUFNLENBQUM7YUFDYixPQUFPLEVBQUUsRUFDWixvQkFBb0IsQ0FDckIsQ0FBQztJQUNKLENBQUM7SUFFRDs7Ozs7Ozs7Ozs7O09BWUc7Ozs7Ozs7Ozs7Ozs7O0lBQ0gsb0NBQU07Ozs7Ozs7Ozs7Ozs7SUFBTixVQUFPLGdCQUF3QixFQUFFLG9CQUE0QjtRQUMzRCxPQUFPLElBQUksQ0FBQyxRQUFRLENBQ2xCLG1CQUFtQixDQUFDLGdCQUFnQixDQUFDLGdCQUFnQixDQUFDO2FBQ25ELE9BQU8sQ0FBQyxNQUFNLENBQUM7YUFDZixPQUFPLEVBQUUsRUFDWixvQkFBb0IsQ0FDckIsQ0FBQztJQUNKLENBQUM7SUFDSCwwQkFBQztBQUFELENBQUMsQUExUUQsSUEwUUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IERhbGUgTG90dHMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuZGFsZWxvdHRzLmNvbVxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWxlbG90dHMvYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7U2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge01vbWVudH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7RGxEYXRlVGltZVBpY2tlck1vZGVsfSBmcm9tICcuL2RsLWRhdGUtdGltZS1waWNrZXItbW9kZWwnO1xuaW1wb3J0IHtEbE1vZGVsUHJvdmlkZXJ9IGZyb20gJy4vZGwtbW9kZWwtcHJvdmlkZXInO1xuXG4vKipcbiAqIFdvcmsgYXJvdW5kIGZvciBtb21lbnQgbmFtZXNwYWNlIGNvbmZsaWN0IHdoZW4gdXNlZCB3aXRoIHdlYnBhY2sgYW5kIHJvbGx1cC5cbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZGhlcmdlcy9uZy1wYWNrYWdyL2lzc3Vlcy8xNjNcbiAqXG4gKiBEZXBlbmRpbmcgb24gd2hldGhlciByb2xsdXAgaXMgdXNlZCwgbW9tZW50IG5lZWRzIHRvIGJlIGltcG9ydGVkIGRpZmZlcmVudGx5LlxuICogU2luY2UgTW9tZW50LmpzIGRvZXNuJ3QgaGF2ZSBhIGRlZmF1bHQgZXhwb3J0LCB3ZSBub3JtYWxseSBuZWVkIHRvIGltcG9ydCB1c2luZ1xuICogdGhlIGAqIGFzYHN5bnRheC5cbiAqXG4gKiByb2xsdXAgY3JlYXRlcyBhIHN5bnRoZXRpYyBkZWZhdWx0IG1vZHVsZSBhbmQgd2UgdGh1cyBuZWVkIHRvIGltcG9ydCBpdCB1c2luZ1xuICogdGhlIGBkZWZhdWx0IGFzYCBzeW50YXguXG4gKlxuICogQGludGVybmFsXG4gKiovXG5jb25zdCBtb21lbnQgPSBfbW9tZW50O1xuXG4vKipcbiAqIERlZmF1bHQgaW1wbGVtZW50YXRpb24gZm9yIHRoZSBgeWVhcmAgdmlldy5cbiAqL1xuZXhwb3J0IGNsYXNzIERsWWVhck1vZGVsUHJvdmlkZXIgaW1wbGVtZW50cyBEbE1vZGVsUHJvdmlkZXIge1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtb21lbnQgYXQgbWlkbmlnaHQgamFudWFyeSAxIGF0IHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqIFRoZSBzdGFydCBvZiB0aGUgZGVjYWRlIGlzIGFsd2F5cyBhIHllYXIgZW5kaW5nIGluIHplcm8uXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgc3RhcnQgb2YgdGhlIGRlY2FkZSB3aWxsIGJlIGRldGVybWluZWQuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb21lbnQgYXQgbWlkbmlnaHQgamFudWFyeSAxIGF0IHRoZSBzdGFydCBvZiB0aGUgY3VycmVudCBkZWNhZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0U3RhcnRPZkRlY2FkZShmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBNb21lbnQge1xuICAgIC8vIFRydW5jYXRlIHRoZSBsYXN0IGRpZ2l0IGZyb20gdGhlIGN1cnJlbnQgeWVhciB0byBnZXQgdGhlIHN0YXJ0IG9mIHRoZSBkZWNhZGVcbiAgICBjb25zdCBzdGFydERlY2FkZSA9IChNYXRoLnRydW5jKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS55ZWFyKCkgLyAxMCkgKiAxMCk7XG4gICAgcmV0dXJuIG1vbWVudCh7eWVhcjogc3RhcnREZWNhZGV9KS5zdGFydE9mKCd5ZWFyJyk7XG4gIH1cblxuICAvKipcbiAgICogUmVjZWl2ZXMgaW5wdXQgY2hhbmdlcyBkZXRlY3RlZCBieSBBbmd1bGFyLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbmdlc1xuICAgKiAgdGhlIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICovXG4gIG9uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYHllYXJgIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiBgbG9jYWxgIHRpbWUgd2l0aCB0aGVcbiAgICogYGFjdGl2ZWAgeWVhciBzZXQgdG8gSmFudWFyeSAxIG9mIHRoZSBzcGVjaWZpZWQgeWVhci5cbiAgICpcbiAgICogVGhlIGB5ZWFyYCBtb2RlbCByZXByZXNlbnRzIGEgZGVjYWRlICgxMCB5ZWFycykgYXMgdHdvIHJvd3Mgd2l0aCBmaXZlIGNvbHVtbnMuXG4gICAqXG4gICAqIFRoZSBkZWNhZGUgYWx3YXlzIHN0YXJ0cyBvbiBhIHllYXIgZW5kaW5nIHdpdGggemVyby5cbiAgICpcbiAgICogRWFjaCBjZWxsIHJlcHJlc2VudHMgbWlkbmlnaHQgSmFudWFyeSAxIG9mIHRoZSBpbmRpY2F0ZWQgeWVhci5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIG9mIHllYXIgb2YgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqXG4gICAqIEBwYXJhbSBtaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSB5ZWFyIG1vZGVsIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIHRoZSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdldE1vZGVsKG1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICBjb25zdCByb3dOdW1iZXJzID0gWzAsIDFdO1xuICAgIGNvbnN0IGNvbHVtbk51bWJlcnMgPSBbMCwgMSwgMiwgMywgNF07XG5cbiAgICBjb25zdCBzdGFydFllYXIgPSBtb21lbnQobWlsbGlzZWNvbmRzKS5zdGFydE9mKCd5ZWFyJyk7XG4gICAgY29uc3Qgc3RhcnREYXRlID0gRGxZZWFyTW9kZWxQcm92aWRlci5nZXRTdGFydE9mRGVjYWRlKG1pbGxpc2Vjb25kcyk7XG5cbiAgICBjb25zdCBmdXR1cmVZZWFyID0gc3RhcnREYXRlLnllYXIoKSArIDk7XG4gICAgY29uc3QgcGFzdFllYXIgPSBzdGFydERhdGUueWVhcigpO1xuICAgIGNvbnN0IGFjdGl2ZVZhbHVlID0gc3RhcnRZZWFyLnZhbHVlT2YoKTtcbiAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IG51bGwgfHwgc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IHVuZGVmaW5lZFxuICAgICAgPyBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAgOiBtb21lbnQoc2VsZWN0ZWRNaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ3llYXInKS52YWx1ZU9mKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld05hbWU6ICd5ZWFyJyxcbiAgICAgIHZpZXdMYWJlbDogYCR7cGFzdFllYXJ9LSR7ZnV0dXJlWWVhcn1gLFxuICAgICAgYWN0aXZlRGF0ZTogYWN0aXZlVmFsdWUsXG4gICAgICBsZWZ0QnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBtb21lbnQoc3RhcnREYXRlKS5zdWJ0cmFjdCgxMCwgJ3llYXJzJykudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke3Bhc3RZZWFyIC0gMTB9LSR7cGFzdFllYXIgLSAxfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHJpZ2h0QnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBtb21lbnQoc3RhcnREYXRlKS5hZGQoMTAsICd5ZWFycycpLnZhbHVlT2YoKSxcbiAgICAgICAgYXJpYUxhYmVsOiBgR28gdG8gJHtmdXR1cmVZZWFyICsgMX0tJHtmdXR1cmVZZWFyICsgMTB9YCxcbiAgICAgICAgY2xhc3Nlczoge30sXG4gICAgICB9LFxuICAgICAgcm93czogcm93TnVtYmVycy5tYXAocm93T2ZZZWFycy5iaW5kKHRoaXMpKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByb3dPZlllYXJzKHJvd051bWJlcikge1xuXG4gICAgICBjb25zdCBjdXJyZW50TW9tZW50ID0gbW9tZW50KCk7XG4gICAgICBjb25zdCBjZWxscyA9IGNvbHVtbk51bWJlcnMubWFwKChjb2x1bW5OdW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgeWVhck1vbWVudCA9IG1vbWVudChzdGFydERhdGUpLmFkZCgocm93TnVtYmVyICogY29sdW1uTnVtYmVycy5sZW5ndGgpICsgY29sdW1uTnVtYmVyLCAneWVhcnMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwbGF5OiB5ZWFyTW9tZW50LmZvcm1hdCgnWVlZWScpLFxuICAgICAgICAgIHZhbHVlOiB5ZWFyTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICBjbGFzc2VzOiB7XG4gICAgICAgICAgICAnZGwtYWJkdHAtYWN0aXZlJzogYWN0aXZlVmFsdWUgPT09IHllYXJNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgICAgJ2RsLWFiZHRwLXNlbGVjdGVkJzogc2VsZWN0ZWRWYWx1ZSA9PT0geWVhck1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgICAnZGwtYWJkdHAtbm93JzogeWVhck1vbWVudC5pc1NhbWUoY3VycmVudE1vbWVudCwgJ3llYXInKSxcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7Y2VsbHN9O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBhY3RpdmUgYHllYXJgIG9uZSByb3cgYGRvd25gIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIGBmaXZlICg1KSB5ZWFycyBhZnRlcmAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIHJvdyBgZG93bmAgaW4gdGhlIGN1cnJlbnQgYHllYXJgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgZG93bmAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgeWVhciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRlY2FkZSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgeWVhcmAgbW9kZWwgYGRvd25gIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGB5ZWFyYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb0Rvd24oZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDUsICd5ZWFyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGB5ZWFyYCBvbmUgcm93IGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBUaGUgYGFjdGl2ZWAgeWVhciB3aWxsIGJlIHRoZSBKYW51YXJ5IDEgYGZpdmUgKDUpIHllYXJzIGJlZm9yZWAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIHJvdyBgdXBgIGluIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBNb3ZpbmcgYHVwYCBjYW4gcmVzdWx0IGluIHRoZSBgYWN0aXZlYCB5ZWFyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgZGVjYWRlIHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AsIGluIHRoaXMgY2FzZSB0aGUgZGVjYWRlIHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBwcmV2aW91cyBgeWVhcmAgbW9kZWwgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgeWVhcmAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvVXAoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoNSwgJ3llYXInKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBgeWVhcmAgb25lICgxKSB5ZWFyIHRvIHRoZSBgbGVmdGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIGBvbmUgKDEpIHllYXIgYmVmb3JlYCB0aGUgc3BlY2lmaWVkIG1pbGxpc2Vjb25kcy5cbiAgICogVGhpcyBtb3ZlcyB0aGUgYGFjdGl2ZWAgZGF0ZSBvbmUgeWVhciBgbGVmdGAgaW4gdGhlIGN1cnJlbnQgYHllYXJgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgbGVmdGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgeWVhciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRlY2FkZSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgYHllYXJgIG1vZGVsIHRvIHRoZSBgbGVmdGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYHllYXJgIG9uZSB5ZWFyIHRvIHRoZSBgbGVmdGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvTGVmdChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdWJ0cmFjdCgxLCAneWVhcicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGB5ZWFyYCBvbmUgKDEpIHllYXIgdG8gdGhlIGByaWdodGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogVGhlIGBhY3RpdmVgIHllYXIgd2lsbCBiZSB0aGUgSmFudWFyeSAxIGBvbmUgKDEpIHllYXIgYWZ0ZXJgIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKiBUaGlzIG1vdmVzIHRoZSBgYWN0aXZlYCBkYXRlIG9uZSB5ZWFyIGByaWdodGAgaW4gdGhlIGN1cnJlbnQgYHllYXJgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgcmlnaHRgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIHllYXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBkZWNhZGUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGB5ZWFyYCBtb2RlbCB0byB0aGUgYHJpZ2h0YCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgeWVhcmAgb25lIHllYXIgdG8gdGhlIGByaWdodGAgb2YgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdvUmlnaHQoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuYWRkKDEsICd5ZWFyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGB5ZWFyYCBvbmUgZGVjYWRlIGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIFRoZSBgYWN0aXZlYCB5ZWFyIHdpbGwgYmUgdGhlIEphbnVhcnkgMSBgdGVuICgxMCkgeWVhcnMgYWZ0ZXJgIHRoZSBzcGVjaWZpZWQgbWlsbGlzZWNvbmRzLlxuICAgKiBUaGlzIG1vdmVzIHRoZSBgYWN0aXZlYCBkYXRlIG9uZSBgcGFnZWAgYGRvd25gIGZyb20gdGhlIGN1cnJlbnQgYHllYXJgIHZpZXcuXG4gICAqXG4gICAqIFBhZ2luZyBgZG93bmAgd2lsbCByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIHllYXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkZWNhZGUgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYC4gQXMgYSByZXN1bHQsIHRoZSBkZWNhZGUgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYHllYXJgIG1vZGVsIHBhZ2UgYGRvd25gIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGB5ZWFyYCBvbmUgZGVjYWRlIGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBwYWdlRG93bihmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5hZGQoMTAsICd5ZWFyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGB5ZWFyYCBvbmUgZGVjYWRlIGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBUaGUgYGFjdGl2ZWAgeWVhciB3aWxsIGJlIHRoZSBKYW51YXJ5IDEgYHRlbiAoMTApIHllYXJzIGJlZm9yZWAgdGhlIHNwZWNpZmllZCBtaWxsaXNlY29uZHMuXG4gICAqIFRoaXMgbW92ZXMgdGhlIGBhY3RpdmVgIGRhdGUgb25lIGBwYWdlLXVwYCBmcm9tIHRoZSBjdXJyZW50IGB5ZWFyYCB2aWV3LlxuICAgKlxuICAgKiBQYWdpbmcgYHVwYCB3aWxsIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgeWVhciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLiBBcyBhIHJlc3VsdCwgdGhlIGRlY2FkZSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgeWVhcmAgbW9kZWwgcGFnZSBgdXBgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGB5ZWFyYCBvbmUgZGVjYWRlIGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgcGFnZVVwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDEwLCAneWVhcicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGB5ZWFyYCB0byB0aGUgYGxhc3RgIHllYXIgaW4gdGhlIGRlY2FkZS5cbiAgICpcbiAgICogVGhlIHZpZXcgb3IgdGltZSByYW5nZSB3aWxsIG5vdCBjaGFuZ2UgdW5sZXNzIHRoZSBgZnJvbU1pbGxpc2Vjb25kc2AgdmFsdWVcbiAgICogaXMgaW4gYSBkaWZmZXJlbnQgZGVjYWRlIHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgYGxhc3RgIGFjdGl2ZSBgeWVhcmAgd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBgbGFzdGAgY2VsbCBpbiB0aGUgdmlldyBhcyB0aGUgYWN0aXZlIGB5ZWFyYC5cbiAgICovXG4gIGdvRW5kKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwoXG4gICAgICBEbFllYXJNb2RlbFByb3ZpZGVyLmdldFN0YXJ0T2ZEZWNhZGUoZnJvbU1pbGxpc2Vjb25kcylcbiAgICAgICAgLmFkZCg5LCAneWVhcnMnKVxuICAgICAgICAuZW5kT2YoJ3llYXInKVxuICAgICAgICAudmFsdWVPZigpLFxuICAgICAgc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGB5ZWFyYCB0byB0aGUgYGZpcnN0YCB5ZWFyIGluIHRoZSBkZWNhZGUuXG4gICAqXG4gICAqIFRoZSB2aWV3IG9yIHRpbWUgcmFuZ2Ugd2lsbCBub3QgY2hhbmdlIHVubGVzcyB0aGUgYGZyb21NaWxsaXNlY29uZHNgIHZhbHVlXG4gICAqIGlzIGluIGEgZGlmZmVyZW50IGRlY2FkZSB0aGFuIHRoZSBkaXNwbGF5ZWQgZGVjYWRlLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGBmaXJzdGAgYWN0aXZlIGB5ZWFyYCB3aWxsIGJlIGNhbGN1bGF0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBhIG1vZGVsIHdpdGggdGhlIGBmaXJzdGAgY2VsbCBpbiB0aGUgdmlldyBhcyB0aGUgYWN0aXZlIGB5ZWFyYC5cbiAgICovXG4gIGdvSG9tZShmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKFxuICAgICAgRGxZZWFyTW9kZWxQcm92aWRlci5nZXRTdGFydE9mRGVjYWRlKGZyb21NaWxsaXNlY29uZHMpXG4gICAgICAgIC5zdGFydE9mKCd5ZWFyJylcbiAgICAgICAgLnZhbHVlT2YoKSxcbiAgICAgIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAgKTtcbiAgfVxufVxuIl19