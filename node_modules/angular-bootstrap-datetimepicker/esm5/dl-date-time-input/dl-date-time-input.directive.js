/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core/public-api';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * \@internal
 * @type {?}
 */
var moment = _moment;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 * @template D
 */
var DlDateTimeInputDirective = /** @class */ (function () {
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    function DlDateTimeInputDirective(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        var _this = this;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            return (_this._inputFilter || ((/**
             * @return {?}
             */
            function () { return true; })))(_this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        });
        this._inputFilter = (/**
         * @return {?}
         */
        function () { return true; });
        this._isValid = true;
        this._parseValidator = (/**
         * @return {?}
         */
        function () {
            return _this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': _this._elementRef.nativeElement.value } };
        });
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.dateChange = new EventEmitter();
    }
    Object.defineProperty(DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", {
        /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         */
        set: /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param {?} inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         * @return {?}
         */
        function (inputFilterFunction) {
            this._inputFilter = inputFilterFunction;
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimeInputDirective.prototype, "value", {
        /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         **/
        get: /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         *
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emit a `change` event when the value of the input changes.
     */
    /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onChange = /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    function () {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    };
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onBlur = /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    function () {
        if (this._value) {
            this.writeValue(this._value);
        }
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) { return onTouched(); }));
    };
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onInput = /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this._value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        this._changed.forEach((/**
         * @param {?} onChanged
         * @return {?}
         */
        function (onChanged) { return onChanged(_this._value); }));
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnChange = /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._changed.push(onChange);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnTouched = /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._touched.push(onTouched);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnValidatorChange = /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    function (validatorOnChange) {
        this._validatorOnChange = validatorOnChange;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.setDisabledState = /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.validate = /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this._validator(control);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.writeValue = /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var normalizedValue = value === null || value === undefined
            ? ''
            : moment(value).format(this._displayFormat);
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DlDateTimeInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[dlDateTimeInput]',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true }
                    ]
                },] }
    ];
    /** @nocollapse */
    DlDateTimeInputDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: DlDateAdapter },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
    ]; };
    DlDateTimeInputDirective.propDecorators = {
        dateChange: [{ type: Output }],
        dlDateTimeInputFilter: [{ type: Input }],
        _onChange: [{ type: HostListener, args: ['change',] }],
        _onBlur: [{ type: HostListener, args: ['blur',] }],
        _onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
    };
    return DlDateTimeInputDirective;
}());
export { DlDateTimeInputDirective };
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._filterValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFilter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._isValid;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._parseValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._changed;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._touched;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._value;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     *
     * @type {?}
     */
    DlDateTimeInputDirective.prototype.dateChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._displayFormat;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFormats;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5SCxPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEdBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDMUcsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7Ozs7O0lBSzVELE1BQU0sR0FBRyxPQUFPOzs7Ozs7OztBQVF0QjtJQWlDRTs7Ozs7Ozs7Ozs7OztPQWFHO0lBQ0gsa0NBQ1UsU0FBb0IsRUFDcEIsV0FBdUIsRUFDdkIsWUFBOEIsRUFDZ0IsY0FBc0IsRUFDdkIsYUFBdUI7UUFMOUUsaUJBTUk7UUFMTSxjQUFTLEdBQVQsU0FBUyxDQUFXO1FBQ3BCLGdCQUFXLEdBQVgsV0FBVyxDQUFZO1FBQ3ZCLGlCQUFZLEdBQVosWUFBWSxDQUFrQjtRQUNnQixtQkFBYyxHQUFkLGNBQWMsQ0FBUTtRQUN2QixrQkFBYSxHQUFiLGFBQWEsQ0FBVTs7UUExQ3RFLHFCQUFnQjs7OztRQUFnQixVQUFDLE9BQXdCO1lBQy9ELE9BQU8sQ0FBQyxLQUFJLENBQUMsWUFBWSxJQUFJOzs7WUFBQyxjQUFNLE9BQUEsSUFBSSxF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QUFTLFNBQUM7b0JBQ1QsUUFBUSxFQUFFLHdCQUF3QjtvQkFDbEMsU0FBUyxFQUFFO3dCQUNULEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFdBQVcsRUFBRSxVQUFVOzs7NEJBQUMsY0FBTSxPQUFBLHdCQUF3QixFQUF4QixDQUF3QixFQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBQzt3QkFDbEcsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRSxVQUFVOzs7NEJBQUMsY0FBTSxPQUFBLHdCQUF3QixFQUF4QixDQUF3QixFQUFDLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBQztxQkFDL0Y7aUJBQ0Y7Ozs7Z0JBaEM2RixTQUFTO2dCQUFwRixVQUFVO2dCQVlvQyxhQUFhOzZDQWlFekUsTUFBTSxTQUFDLDJCQUEyQjs0Q0FDbEMsTUFBTSxTQUFDLDBCQUEwQjs7OzZCQXRCbkMsTUFBTTt3Q0E4Qk4sS0FBSzs0QkFrQkwsWUFBWSxTQUFDLFFBQVE7MEJBT3JCLFlBQVksU0FBQyxNQUFNOzJCQWFuQixZQUFZLFNBQUMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUM7O0lBc0RoRCwrQkFBQztDQUFBLEFBeEpELElBd0pDO1NBakpZLHdCQUF3Qjs7Ozs7O0lBR25DLG9EQUdDOzs7OztJQUNELGdEQUFrRTs7Ozs7SUFDbEUsNENBQXdCOzs7OztJQUN4QixtREFHQzs7Ozs7SUFDRCw0Q0FBOEM7Ozs7O0lBQzlDLDRDQUFzQzs7Ozs7SUFDdEMsOENBQXVGOzs7OztJQUN2RixzREFBa0Q7Ozs7O0lBQ2xELDBDQUEwQzs7Ozs7OztJQU0xQyw4Q0FDbUU7Ozs7O0lBaUJqRSw2Q0FBNEI7Ozs7O0lBQzVCLCtDQUErQjs7Ozs7SUFDL0IsZ0RBQXNDOzs7OztJQUN0QyxrREFBNEU7Ozs7O0lBQzVFLGlEQUE0RSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7RGlyZWN0aXZlLCBFbGVtZW50UmVmLCBFdmVudEVtaXR0ZXIsIGZvcndhcmRSZWYsIEhvc3RMaXN0ZW5lciwgSW5qZWN0LCBJbnB1dCwgT3V0cHV0LCBSZW5kZXJlcjJ9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RDb250cm9sLFxuICBDb250cm9sVmFsdWVBY2Nlc3NvcixcbiAgTkdfVkFMSURBVE9SUyxcbiAgTkdfVkFMVUVfQUNDRVNTT1IsXG4gIFZhbGlkYXRpb25FcnJvcnMsXG4gIFZhbGlkYXRvcixcbiAgVmFsaWRhdG9yRm4sXG4gIFZhbGlkYXRvcnMsXG59IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCAqIGFzIF9tb21lbnQgZnJvbSAnbW9tZW50JztcbmltcG9ydCB7RExfREFURV9USU1FX0RJU1BMQVlfRk9STUFULCBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUywgRGxEYXRlQWRhcHRlcn0gZnJvbSAnLi4vY29yZS9wdWJsaWMtYXBpJztcbmltcG9ydCB7RGxEYXRlVGltZUlucHV0Q2hhbmdlfSBmcm9tICcuL2RsLWRhdGUtdGltZS1pbnB1dC1jaGFuZ2UnO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBtb21lbnQgPSBfbW9tZW50O1xuXG4vKipcbiAqICBUaGlzIGRpcmVjdGl2ZSBhbGxvd3MgdGhlIHVzZXIgdG8gZW50ZXIgZGF0ZXMsIHVzaW5nIHRoZSBrZXlib2FyZCwgaW50byBhbiBpbnB1dCBib3ggYW5kXG4gKiAgYW5ndWxhciB3aWxsIHRoZW4gc3RvcmUgYSBkYXRlIHZhbHVlIGluIHRoZSBtb2RlbC5cbiAqXG4gKiAgVGhlIGlucHV0IGZvcm1hdChzKSwgZGlzcGxheSBmb3JtYXQsIGFuZCBtb2RlbCBmb3JtYXQgYXJlIGluZGVwZW5kZW50IGFuZCBmdWxseSBjdXN0b21pemFibGUuXG4gKi9cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ2lucHV0W2RsRGF0ZVRpbWVJbnB1dF0nLFxuICBwcm92aWRlcnM6IFtcbiAgICB7cHJvdmlkZTogTkdfVkFMVUVfQUNDRVNTT1IsIHVzZUV4aXN0aW5nOiBmb3J3YXJkUmVmKCgpID0+IERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZSksIG11bHRpOiB0cnVlfSxcbiAgICB7cHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlKSwgbXVsdGk6IHRydWV9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlPEQ+IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nICovXG4gIHByaXZhdGUgX2ZpbHRlclZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIHJldHVybiAodGhpcy5faW5wdXRGaWx0ZXIgfHwgKCgpID0+IHRydWUpKSh0aGlzLl92YWx1ZSkgP1xuICAgICAgbnVsbCA6IHsnZGxEYXRlVGltZUlucHV0RmlsdGVyJzogeyd2YWx1ZSc6IGNvbnRyb2wudmFsdWV9fTtcbiAgfVxuICBwcml2YXRlIF9pbnB1dEZpbHRlcjogKHZhbHVlOiAoRCB8IG51bGwpKSA9PiBib29sZWFuID0gKCkgPT4gdHJ1ZTtcbiAgcHJpdmF0ZSBfaXNWYWxpZCA9IHRydWU7XG4gIHByaXZhdGUgX3BhcnNlVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9ICgpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgcmV0dXJuIHRoaXMuX2lzVmFsaWQgP1xuICAgICAgbnVsbCA6IHsnZGxEYXRlVGltZUlucHV0UGFyc2UnOiB7J3RleHQnOiB0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQudmFsdWV9fTtcbiAgfVxuICBwcml2YXRlIF9jaGFuZ2VkOiAoKHZhbHVlOiBEKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgX3RvdWNoZWQ6ICgoKSA9PiB2b2lkKVtdID0gW107XG4gIHByaXZhdGUgX3ZhbGlkYXRvciA9IFZhbGlkYXRvcnMuY29tcG9zZShbdGhpcy5fcGFyc2VWYWxpZGF0b3IsIHRoaXMuX2ZpbHRlclZhbGlkYXRvcl0pO1xuICBwcml2YXRlIF92YWxpZGF0b3JPbkNoYW5nZTogKCkgPT4gdm9pZCA9ICgpID0+IHt9O1xuICBwcml2YXRlIF92YWx1ZTogRCB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogRW1pdHMgd2hlbiBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gZGF0ZS90aW1lIGlzIHNlbGVjdGVkIG9yXG4gICAqIHRoZSB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlciBjaGFuZ2VzLlxuICAgKiovXG4gIEBPdXRwdXQoKVxuICByZWFkb25seSBkYXRlQ2hhbmdlID0gbmV3IEV2ZW50RW1pdHRlcjxEbERhdGVUaW1lSW5wdXRDaGFuZ2U8RD4+KCk7XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdHMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhpcyBkaXJlY3RpdmUuXG4gICAqIEBwYXJhbSBfcmVuZGVyZXJcbiAgICogIHJlZmVyZW5jZSB0byB0aGUgcmVuZGVyZXIuXG4gICAqIEBwYXJhbSBfZWxlbWVudFJlZlxuICAgKiAgcmVmZXJlbmNlIHRvIHRoaXMgZWxlbWVudC5cbiAgICogQHBhcmFtIF9kYXRlQWRhcHRlclxuICAgKiAgZGF0ZSBhZGFwdGVyIGZvciB0aGUgZGF0ZSB0eXBlIGluIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIF9kaXNwbGF5Rm9ybWF0XG4gICAqICBmcm9tIGBETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVRgLCB3aGljaCBkZWZpbmVzIHRoZSBmb3JtYXQgdG8gdXNlIGZvciBhIHZhbGlkIGRhdGUvdGltZSB2YWx1ZS5cbiAgICogQHBhcmFtIF9pbnB1dEZvcm1hdHNcbiAgICogIGZyb20gYERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTYCwgd2hpY2ggZGVmaW5lcyB0aGUgaW5wdXQgZm9ybWF0cyB0aGF0IGFsbG93ZWQgYXMgdmFsaWQgZGF0ZS90aW1lIHZhbHVlcy5cbiAgICogIE5COiBtb21lbnQgaXMgYWx3YXlzIGluIHN0cmljdCBwYXJzZSBtb2RlIGZvciB0aGlzIGRpcmVjdGl2ZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgX3JlbmRlcmVyOiBSZW5kZXJlcjIsXG4gICAgcHJpdmF0ZSBfZWxlbWVudFJlZjogRWxlbWVudFJlZixcbiAgICBwcml2YXRlIF9kYXRlQWRhcHRlcjogRGxEYXRlQWRhcHRlcjxEPixcbiAgICBASW5qZWN0KERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVCkgcHJpdmF0ZSByZWFkb25seSBfZGlzcGxheUZvcm1hdDogc3RyaW5nLFxuICAgIEBJbmplY3QoRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFMpIHByaXZhdGUgcmVhZG9ubHkgX2lucHV0Rm9ybWF0czogc3RyaW5nW11cbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBTZXQgYSBmdW5jdGlvbiB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIG9yIG5vdCB0aGUgYHZhbHVlYCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlzIGFsbG93ZWQuXG4gICAqIEBwYXJhbSBpbnB1dEZpbHRlckZ1bmN0aW9uXG4gICAqICAgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZCwgb3RoZXJ3aXNlIGBmYWxzZWAuXG4gICAqL1xuICBASW5wdXQoKVxuICBzZXQgZGxEYXRlVGltZUlucHV0RmlsdGVyKGlucHV0RmlsdGVyRnVuY3Rpb246ICh2YWx1ZTogRCB8IG51bGwpID0+IGJvb2xlYW4pIHtcbiAgICB0aGlzLl9pbnB1dEZpbHRlciA9IGlucHV0RmlsdGVyRnVuY3Rpb247XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UoKTtcbiAgfVxuXG4gIC8qIHRzbGludDplbmFibGU6bWVtYmVyLW9yZGVyaW5nICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYERgIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXQgb3IgYHVuZGVmaW5lZGAgfCBgbnVsbGAgaWYgbm8gdmFsdWUgaXMgc2V0LlxuICAgKiovXG4gIGdldCB2YWx1ZSgpOiBEIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBjaGFuZ2VzLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJykgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG5ldyBEbERhdGVUaW1lSW5wdXRDaGFuZ2UodGhpcy5fdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGlucHV0IHRleHQgdXNpbmcge0BsaW5rIERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVH0gYW5kIG1hcmsgdGhlIGNvbnRyb2wgYXMgdG91Y2hlZC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBfb25CbHVyKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy53cml0ZVZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fdG91Y2hlZC5mb3JFYWNoKG9uVG91Y2hlZCA9PiBvblRvdWNoZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIHVzZXIgaW5wdXQgaW50byBhIHBvc3NpYmx5IHZhbGlkIGRhdGUuXG4gICAqIFRoZSBtb2RlbCB2YWx1ZSBpcyBub3Qgc2V0IGlmIHRoZSBpbnB1dCBpcyBOT1Qgb25lIG9mIHRoZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9LlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogICBWYWx1ZSBvZiB0aGUgaW5wdXQgY29udHJvbC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pIF9vbklucHV0KHZhbHVlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgY29uc3QgdGVzdERhdGUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJ1xuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogbW9tZW50KHZhbHVlLCB0aGlzLl9pbnB1dEZvcm1hdHMsIHRydWUpO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IHRlc3REYXRlICYmIHRlc3REYXRlLmlzVmFsaWQoKTtcbiAgICB0aGlzLl92YWx1ZSA9IHRoaXMuX2lzVmFsaWQgPyB0aGlzLl9kYXRlQWRhcHRlci5mcm9tTWlsbGlzZWNvbmRzKHRlc3REYXRlLnZhbHVlT2YoKSkgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5fY2hhbmdlZC5mb3JFYWNoKG9uQ2hhbmdlZCA9PiBvbkNoYW5nZWQodGhpcy5fdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlZC5wdXNoKG9uQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3RvdWNoZWQucHVzaChvblRvdWNoZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSh2YWxpZGF0b3JPbkNoYW5nZTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3ZhbGlkYXRvck9uQ2hhbmdlID0gdmFsaWRhdG9yT25DaGFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB3cml0ZVZhbHVlKHZhbHVlOiBEKTogdm9pZCB7XG4gICAgY29uc3Qgbm9ybWFsaXplZFZhbHVlID0gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZFxuICAgICAgPyAnJ1xuICAgICAgOiBtb21lbnQodmFsdWUpLmZvcm1hdCh0aGlzLl9kaXNwbGF5Rm9ybWF0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG5vcm1hbGl6ZWRWYWx1ZSk7XG4gIH1cbn1cbiJdfQ==