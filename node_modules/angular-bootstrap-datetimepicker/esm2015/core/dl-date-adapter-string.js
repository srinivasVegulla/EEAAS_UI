/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject } from '@angular/core';
import * as _moment from 'moment';
import { DlDateAdapter } from './dl-date-adapter';
import { DL_DATE_TIME_INPUT_FORMATS, DL_DATE_TIME_MODEL_FORMAT } from './dl-date-time-string-format';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 *
 * @type {?}
 */
const moment = _moment;
/**
 * Adapts `string` to be usable as a date by date/time components that work with dates.
 *
 */
export class DlDateAdapterString extends DlDateAdapter {
    /**
     *  Constructs a new instance of this class.
     *
     * @param {?} inputFormats
     *  see {\@link DL_DATE_TIME_INPUT_FORMATS}
     * @param {?} modelFormat
     *  see {\@link DL_DATE_TIME_MODEL_FORMAT}
     */
    constructor(inputFormats, modelFormat) {
        super();
        this.inputFormats = inputFormats;
        this.modelFormat = modelFormat;
    }
    /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    fromMilliseconds(milliseconds) {
        return moment(milliseconds).format(this.modelFormat);
    }
    /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    toMilliseconds(value) {
        if (value !== undefined && value !== null) {
            /** @type {?} */
            const newMoment = moment(value, this.inputFormats, true);
            return newMoment.isValid() ? newMoment.valueOf() : undefined;
        }
    }
}
/** @nocollapse */
DlDateAdapterString.ctorParameters = () => [
    { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] },
    { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_MODEL_FORMAT,] }] }
];
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateAdapterString.prototype.inputFormats;
    /**
     * @type {?}
     * @private
     */
    DlDateAdapterString.prototype.modelFormat;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS1hZGFwdGVyLXN0cmluZy5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiY29yZS9kbC1kYXRlLWFkYXB0ZXItc3RyaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3JDLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNoRCxPQUFPLEVBQUMsMEJBQTBCLEVBQUUseUJBQXlCLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7TUFnQjdGLE1BQU0sR0FBRyxPQUFPOzs7OztBQUt0QixNQUFNLE9BQU8sbUJBQW9CLFNBQVEsYUFBcUI7Ozs7Ozs7OztJQWE1RCxZQUFnRCxZQUFzQixFQUN2QixXQUFtQjtRQUNoRSxLQUFLLEVBQUUsQ0FBQztRQUNSLElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDO1FBQ2pDLElBQUksQ0FBQyxXQUFXLEdBQUcsV0FBVyxDQUFDO0lBQ2pDLENBQUM7Ozs7Ozs7O0lBU0QsZ0JBQWdCLENBQUMsWUFBb0I7UUFDbkMsT0FBTyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUN2RCxDQUFDOzs7Ozs7Ozs7SUFVRCxjQUFjLENBQUMsS0FBb0I7UUFDakMsSUFBSSxLQUFLLEtBQUssU0FBUyxJQUFJLEtBQUssS0FBSyxJQUFJLEVBQUU7O2tCQUNuQyxTQUFTLEdBQUcsTUFBTSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsWUFBWSxFQUFFLElBQUksQ0FBQztZQUN4RCxPQUFPLFNBQVMsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUM7U0FDOUQ7SUFDSCxDQUFDOzs7O3dDQS9CWSxNQUFNLFNBQUMsMEJBQTBCO3lDQUNqQyxNQUFNLFNBQUMseUJBQXlCOzs7Ozs7O0lBWjdDLDJDQUF3Qzs7Ozs7SUFDeEMsMENBQXFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtJbmplY3R9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtEbERhdGVBZGFwdGVyfSBmcm9tICcuL2RsLWRhdGUtYWRhcHRlcic7XG5pbXBvcnQge0RMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTLCBETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUfSBmcm9tICcuL2RsLWRhdGUtdGltZS1zdHJpbmctZm9ybWF0JztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICpcbiAqKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogQWRhcHRzIGBzdHJpbmdgIHRvIGJlIHVzYWJsZSBhcyBhIGRhdGUgYnkgZGF0ZS90aW1lIGNvbXBvbmVudHMgdGhhdCB3b3JrIHdpdGggZGF0ZXMuXG4gKiovXG5leHBvcnQgY2xhc3MgRGxEYXRlQWRhcHRlclN0cmluZyBleHRlbmRzIERsRGF0ZUFkYXB0ZXI8c3RyaW5nPiB7XG5cbiAgcHJpdmF0ZSByZWFkb25seSBpbnB1dEZvcm1hdHM6IHN0cmluZ1tdO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vZGVsRm9ybWF0OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqICBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dEZvcm1hdHNcbiAgICogIHNlZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9XG4gICAqIEBwYXJhbSBtb2RlbEZvcm1hdFxuICAgKiAgc2VlIHtAbGluayBETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUfVxuICAgKi9cbiAgY29uc3RydWN0b3IoQEluamVjdChETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUykgaW5wdXRGb3JtYXRzOiBzdHJpbmdbXSxcbiAgICAgICAgICAgICAgQEluamVjdChETF9EQVRFX1RJTUVfTU9ERUxfRk9STUFUKSBtb2RlbEZvcm1hdDogc3RyaW5nKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlucHV0Rm9ybWF0cyA9IGlucHV0Rm9ybWF0cztcbiAgICB0aGlzLm1vZGVsRm9ybWF0ID0gbW9kZWxGb3JtYXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAgICogQHBhcmFtIG1pbGxpc2Vjb25kc1xuICAgKiAgYSBtb21lbnQgdGltZSB0aW1lLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGZyb21NaWxsaXNlY29uZHMobWlsbGlzZWNvbmRzOiBudW1iZXIpOiBzdHJpbmcge1xuICAgIHJldHVybiBtb21lbnQobWlsbGlzZWNvbmRzKS5mb3JtYXQodGhpcy5tb2RlbEZvcm1hdCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3BlY2lmaWVkIG51bWJlci5cbiAgICogQHBhcmFtIHZhbHVlXG4gICAqICBhIG1vbWVudCB0aW1lIHRpbWUgb3IgYG51bGxgXG4gICAqIEByZXR1cm5zXG4gICAqICB0aGUgbWlsbGlzZWNvbmRzIGZvciB0aGUgc3BlY2lmaWVkIHZhbHVlIG9yIGBudWxsYFxuICAgKiAgYG51bGxgIGlzIHJldHVybmVkIHdoZW4gdmFsdWUgaXMgbm90IGEgdmFsaWQgaW5wdXQgZGF0ZSBzdHJpbmdcbiAgICovXG4gIHRvTWlsbGlzZWNvbmRzKHZhbHVlOiBzdHJpbmcgfCBudWxsKTogbnVtYmVyIHwgbnVsbCB7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgIGNvbnN0IG5ld01vbWVudCA9IG1vbWVudCh2YWx1ZSwgdGhpcy5pbnB1dEZvcm1hdHMsIHRydWUpO1xuICAgICAgcmV0dXJuIG5ld01vbWVudC5pc1ZhbGlkKCkgPyBuZXdNb21lbnQudmFsdWVPZigpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuIl19