/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Directive, ElementRef, EventEmitter, forwardRef, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core/public-api';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * \@internal
 * @type {?}
 */
const moment = _moment;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 * @template D
 */
export class DlDateTimeInputDirective {
    /**
     * Constructs a new instance of this directive.
     * @param {?} _renderer
     *  reference to the renderer.
     * @param {?} _elementRef
     *  reference to this element.
     * @param {?} _dateAdapter
     *  date adapter for the date type in the model.
     * @param {?} _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param {?} _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    constructor(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (/**
         * @param {?} control
         * @return {?}
         */
        (control) => {
            return (this._inputFilter || ((/**
             * @return {?}
             */
            () => true)))(this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        });
        this._inputFilter = (/**
         * @return {?}
         */
        () => true);
        this._isValid = true;
        this._parseValidator = (/**
         * @return {?}
         */
        () => {
            return this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': this._elementRef.nativeElement.value } };
        });
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._validatorOnChange = (/**
         * @return {?}
         */
        () => { });
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.dateChange = new EventEmitter();
    }
    /**
     * Set a function used to determine whether or not the `value` entered by the user is allowed.
     * @param {?} inputFilterFunction
     *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
     * @return {?}
     */
    set dlDateTimeInputFilter(inputFilterFunction) {
        this._inputFilter = inputFilterFunction;
        this._validatorOnChange();
    }
    /* tslint:enable:member-ordering */
    /**
     * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
     *
     * @return {?}
     */
    get value() {
        return this._value;
    }
    /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    _onChange() {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    }
    /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    _onBlur() {
        if (this._value) {
            this.writeValue(this._value);
        }
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        onTouched => onTouched()));
    }
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    _onInput(value) {
        /** @type {?} */
        const testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this._value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        this._changed.forEach((/**
         * @param {?} onChanged
         * @return {?}
         */
        onChanged => onChanged(this._value)));
    }
    /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    registerOnChange(onChange) {
        this._changed.push(onChange);
    }
    /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    registerOnTouched(onTouched) {
        this._touched.push(onTouched);
    }
    /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    registerOnValidatorChange(validatorOnChange) {
        this._validatorOnChange = validatorOnChange;
    }
    /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    validate(control) {
        return this._validator(control);
    }
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    writeValue(value) {
        /** @type {?} */
        const normalizedValue = value === null || value === undefined
            ? ''
            : moment(value).format(this._displayFormat);
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    }
}
DlDateTimeInputDirective.decorators = [
    { type: Directive, args: [{
                selector: 'input[dlDateTimeInput]',
                providers: [
                    { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DlDateTimeInputDirective)), multi: true },
                    { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                         * @return {?}
                         */
                        () => DlDateTimeInputDirective)), multi: true }
                ]
            },] }
];
/** @nocollapse */
DlDateTimeInputDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DlDateAdapter },
    { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
    { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
];
DlDateTimeInputDirective.propDecorators = {
    dateChange: [{ type: Output }],
    dlDateTimeInputFilter: [{ type: Input }],
    _onChange: [{ type: HostListener, args: ['change',] }],
    _onBlur: [{ type: HostListener, args: ['blur',] }],
    _onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._filterValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFilter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._isValid;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._parseValidator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._changed;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._touched;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validator;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._validatorOnChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._value;
    /**
     * Emits when a `change` event when date/time is selected or
     * the value of the date/time picker changes.
     *
     * @type {?}
     */
    DlDateTimeInputDirective.prototype.dateChange;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._renderer;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._elementRef;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._dateAdapter;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._displayFormat;
    /**
     * @type {?}
     * @private
     */
    DlDateTimeInputDirective.prototype._inputFormats;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUM5SCxPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEdBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDMUcsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7Ozs7O01BSzVELE1BQU0sR0FBRyxPQUFPOzs7Ozs7OztBQWV0QixNQUFNLE9BQU8sd0JBQXdCOzs7Ozs7Ozs7Ozs7Ozs7SUF3Q25DLFlBQ1UsU0FBb0IsRUFDcEIsV0FBdUIsRUFDdkIsWUFBOEIsRUFDZ0IsY0FBc0IsRUFDdkIsYUFBdUI7UUFKcEUsY0FBUyxHQUFULFNBQVMsQ0FBVztRQUNwQixnQkFBVyxHQUFYLFdBQVcsQ0FBWTtRQUN2QixpQkFBWSxHQUFaLFlBQVksQ0FBa0I7UUFDZ0IsbUJBQWMsR0FBZCxjQUFjLENBQVE7UUFDdkIsa0JBQWEsR0FBYixhQUFhLENBQVU7O1FBMUN0RSxxQkFBZ0I7Ozs7UUFBZ0IsQ0FBQyxPQUF3QixFQUEyQixFQUFFO1lBQzVGLE9BQU8sQ0FBQyxJQUFJLENBQUMsWUFBWSxJQUFJOzs7WUFBQyxHQUFHLEVB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OztZQWhDNkYsU0FBUztZQUFwRixVQUFVO1lBWW9DLGFBQWE7eUNBaUV6RSxNQUFNLFNBQUMsMkJBQTJCO3dDQUNsQyxNQUFNLFNBQUMsMEJBQTBCOzs7eUJBdEJuQyxNQUFNO29DQThCTixLQUFLO3dCQWtCTCxZQUFZLFNBQUMsUUFBUTtzQkFPckIsWUFBWSxTQUFDLE1BQU07dUJBYW5CLFlBQVksU0FBQyxPQUFPLEVBQUUsQ0FBQyxxQkFBcUIsQ0FBQzs7Ozs7OztJQXhGOUMsb0RBR0M7Ozs7O0lBQ0QsZ0RBQWtFOzs7OztJQUNsRSw0Q0FBd0I7Ozs7O0lBQ3hCLG1EQUdDOzs7OztJQUNELDRDQUE4Qzs7Ozs7SUFDOUMsNENBQXNDOzs7OztJQUN0Qyw4Q0FBdUY7Ozs7O0lBQ3ZGLHNEQUFrRDs7Ozs7SUFDbEQsMENBQTBDOzs7Ozs7O0lBTTFDLDhDQUNtRTs7Ozs7SUFpQmpFLDZDQUE0Qjs7Ozs7SUFDNUIsK0NBQStCOzs7OztJQUMvQixnREFBc0M7Ozs7O0lBQ3RDLGtEQUE0RTs7Ozs7SUFDNUUsaURBQTRFIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgZm9yd2FyZFJlZiwgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBBYnN0cmFjdENvbnRyb2wsXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICBOR19WQUxJREFUT1JTLFxuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgVmFsaWRhdGlvbkVycm9ycyxcbiAgVmFsaWRhdG9yLFxuICBWYWxpZGF0b3JGbixcbiAgVmFsaWRhdG9ycyxcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVQsIERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTLCBEbERhdGVBZGFwdGVyfSBmcm9tICcuLi9jb3JlL3B1YmxpYy1hcGknO1xuaW1wb3J0IHtEbERhdGVUaW1lSW5wdXRDaGFuZ2V9IGZyb20gJy4vZGwtZGF0ZS10aW1lLWlucHV0LWNoYW5nZSc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogIFRoaXMgZGlyZWN0aXZlIGFsbG93cyB0aGUgdXNlciB0byBlbnRlciBkYXRlcywgdXNpbmcgdGhlIGtleWJvYXJkLCBpbnRvIGFuIGlucHV0IGJveCBhbmRcbiAqICBhbmd1bGFyIHdpbGwgdGhlbiBzdG9yZSBhIGRhdGUgdmFsdWUgaW4gdGhlIG1vZGVsLlxuICpcbiAqICBUaGUgaW5wdXQgZm9ybWF0KHMpLCBkaXNwbGF5IGZvcm1hdCwgYW5kIG1vZGVsIGZvcm1hdCBhcmUgaW5kZXBlbmRlbnQgYW5kIGZ1bGx5IGN1c3RvbWl6YWJsZS5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbZGxEYXRlVGltZUlucHV0XScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlKSwgbXVsdGk6IHRydWV9LFxuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogZm9yd2FyZFJlZigoKSA9PiBEbERhdGVUaW1lSW5wdXREaXJlY3RpdmUpLCBtdWx0aTogdHJ1ZX1cbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBEbERhdGVUaW1lSW5wdXREaXJlY3RpdmU8RD4gaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgVmFsaWRhdG9yIHtcblxuICAvKiB0c2xpbnQ6ZGlzYWJsZTptZW1iZXItb3JkZXJpbmcgKi9cbiAgcHJpdmF0ZSBfZmlsdGVyVmFsaWRhdG9yOiBWYWxpZGF0b3JGbiA9IChjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCA9PiB7XG4gICAgcmV0dXJuICh0aGlzLl9pbnB1dEZpbHRlciB8fCAoKCkgPT4gdHJ1ZSkpKHRoaXMuX3ZhbHVlKSA/XG4gICAgICBudWxsIDogeydkbERhdGVUaW1lSW5wdXRGaWx0ZXInOiB7J3ZhbHVlJzogY29udHJvbC52YWx1ZX19O1xuICB9XG4gIHByaXZhdGUgX2lucHV0RmlsdGVyOiAodmFsdWU6IChEIHwgbnVsbCkpID0+IGJvb2xlYW4gPSAoKSA9PiB0cnVlO1xuICBwcml2YXRlIF9pc1ZhbGlkID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfcGFyc2VWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZCA/XG4gICAgICBudWxsIDogeydkbERhdGVUaW1lSW5wdXRQYXJzZSc6IHsndGV4dCc6IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZX19O1xuICB9XG4gIHByaXZhdGUgX2NoYW5nZWQ6ICgodmFsdWU6IEQpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdG91Y2hlZDogKCgpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLl9wYXJzZVZhbGlkYXRvciwgdGhpcy5fZmlsdGVyVmFsaWRhdG9yXSk7XG4gIHByaXZhdGUgX3ZhbGlkYXRvck9uQ2hhbmdlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gIHByaXZhdGUgX3ZhbHVlOiBEIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgd2hlbiBkYXRlL3RpbWUgaXMgc2VsZWN0ZWQgb3JcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyIGNoYW5nZXMuXG4gICAqKi9cbiAgQE91dHB1dCgpXG4gIHJlYWRvbmx5IGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERsRGF0ZVRpbWVJbnB1dENoYW5nZTxEPj4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGRpcmVjdGl2ZS5cbiAgICogQHBhcmFtIF9yZW5kZXJlclxuICAgKiAgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIF9lbGVtZW50UmVmXG4gICAqICByZWZlcmVuY2UgdG8gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0gX2RhdGVBZGFwdGVyXG4gICAqICBkYXRlIGFkYXB0ZXIgZm9yIHRoZSBkYXRlIHR5cGUgaW4gdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gX2Rpc3BsYXlGb3JtYXRcbiAgICogIGZyb20gYERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVGAsIHdoaWNoIGRlZmluZXMgdGhlIGZvcm1hdCB0byB1c2UgZm9yIGEgdmFsaWQgZGF0ZS90aW1lIHZhbHVlLlxuICAgKiBAcGFyYW0gX2lucHV0Rm9ybWF0c1xuICAgKiAgZnJvbSBgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFNgLCB3aGljaCBkZWZpbmVzIHRoZSBpbnB1dCBmb3JtYXRzIHRoYXQgYWxsb3dlZCBhcyB2YWxpZCBkYXRlL3RpbWUgdmFsdWVzLlxuICAgKiAgTkI6IG1vbWVudCBpcyBhbHdheXMgaW4gc3RyaWN0IHBhcnNlIG1vZGUgZm9yIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEbERhdGVBZGFwdGVyPEQ+LFxuICAgIEBJbmplY3QoRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUKSBwcml2YXRlIHJlYWRvbmx5IF9kaXNwbGF5Rm9ybWF0OiBzdHJpbmcsXG4gICAgQEluamVjdChETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUykgcHJpdmF0ZSByZWFkb25seSBfaW5wdXRGb3JtYXRzOiBzdHJpbmdbXVxuICApIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZC5cbiAgICogQHBhcmFtIGlucHV0RmlsdGVyRnVuY3Rpb25cbiAgICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgZW50ZXJlZCBieSB0aGUgdXNlciBpcyBhbGxvd2VkLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBkbERhdGVUaW1lSW5wdXRGaWx0ZXIoaW5wdXRGaWx0ZXJGdW5jdGlvbjogKHZhbHVlOiBEIHwgbnVsbCkgPT4gYm9vbGVhbikge1xuICAgIHRoaXMuX2lucHV0RmlsdGVyID0gaW5wdXRGaWx0ZXJGdW5jdGlvbjtcbiAgICB0aGlzLl92YWxpZGF0b3JPbkNoYW5nZSgpO1xuICB9XG5cbiAgLyogdHNsaW50OmVuYWJsZTptZW1iZXItb3JkZXJpbmcgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBgRGAgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBpbnB1dCBvciBgdW5kZWZpbmVkYCB8IGBudWxsYCBpZiBubyB2YWx1ZSBpcyBzZXQuXG4gICAqKi9cbiAgZ2V0IHZhbHVlKCk6IEQge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgYGNoYW5nZWAgZXZlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGNoYW5nZXMuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjaGFuZ2UnKSBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IERsRGF0ZVRpbWVJbnB1dENoYW5nZSh0aGlzLl92YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgaW5wdXQgdGV4dCB1c2luZyB7QGxpbmsgRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUfSBhbmQgbWFyayB0aGUgY29udHJvbCBhcyB0b3VjaGVkLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpIF9vbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLndyaXRlVmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl90b3VjaGVkLmZvckVhY2gob25Ub3VjaGVkID0+IG9uVG91Y2hlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgdXNlciBpbnB1dCBpbnRvIGEgcG9zc2libHkgdmFsaWQgZGF0ZS5cbiAgICogVGhlIG1vZGVsIHZhbHVlIGlzIG5vdCBzZXQgaWYgdGhlIGlucHV0IGlzIE5PVCBvbmUgb2YgdGhlIHtAbGluayBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUU30uXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiAgIFZhbHVlIG9mIHRoZSBpbnB1dCBjb250cm9sLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignaW5wdXQnLCBbJyRldmVudC50YXJnZXQudmFsdWUnXSkgX29uSW5wdXQodmFsdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZXN0RGF0ZSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBtb21lbnQodmFsdWUsIHRoaXMuX2lucHV0Rm9ybWF0cywgdHJ1ZSk7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gdGVzdERhdGUgJiYgdGVzdERhdGUuaXNWYWxpZCgpO1xuICAgIHRoaXMuX3ZhbHVlID0gdGhpcy5faXNWYWxpZCA/IHRoaXMuX2RhdGVBZGFwdGVyLmZyb21NaWxsaXNlY29uZHModGVzdERhdGUudmFsdWVPZigpKSA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9jaGFuZ2VkLmZvckVhY2gob25DaGFuZ2VkID0+IG9uQ2hhbmdlZCh0aGlzLl92YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogKHZhbHVlOiBhbnkpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9jaGFuZ2VkLnB1c2gob25DaGFuZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdG91Y2hlZC5wdXNoKG9uVG91Y2hlZCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWdpc3Rlck9uVmFsaWRhdG9yQ2hhbmdlKHZhbGlkYXRvck9uQ2hhbmdlOiAoKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fdmFsaWRhdG9yT25DaGFuZ2UgPSB2YWxpZGF0b3JPbkNoYW5nZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQge1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ2Rpc2FibGVkJywgaXNEaXNhYmxlZCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB2YWxpZGF0ZShjb250cm9sOiBBYnN0cmFjdENvbnRyb2wpOiBWYWxpZGF0aW9uRXJyb3JzIHwgbnVsbCB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbGlkYXRvcihjb250cm9sKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHdyaXRlVmFsdWUodmFsdWU6IEQpOiB2b2lkIHtcbiAgICBjb25zdCBub3JtYWxpemVkVmFsdWUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkXG4gICAgICA/ICcnXG4gICAgICA6IG1vbWVudCh2YWx1ZSkuZm9ybWF0KHRoaXMuX2Rpc3BsYXlGb3JtYXQpO1xuICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbm9ybWFsaXplZFZhbHVlKTtcbiAgfVxufVxuIl19