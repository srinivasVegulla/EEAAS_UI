import { __extends } from 'tslib';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators } from '@angular/forms';
import { take } from 'rxjs/operators';
import * as _moment from 'moment';
import _moment__default, {  } from 'moment';
import { CommonModule } from '@angular/common';
import { InjectionToken, Inject, NgModule, Directive, ElementRef, EventEmitter, forwardRef, HostListener, Input, Output, Renderer2, ChangeDetectionStrategy, Component, NgZone } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Determines the model type of the Date/Time picker another type.
 * @abstract
 * @template D
 */
var  /**
 * Determines the model type of the Date/Time picker another type.
 * @abstract
 * @template D
 */
DlDateAdapter = /** @class */ (function () {
    function DlDateAdapter() {
    }
    return DlDateAdapter;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment = _moment;
/**
 * Adapts `moment` to be usable as a date by date/time components that work with dates.
 *
 */
var  /**
 * Adapts `moment` to be usable as a date by date/time components that work with dates.
 *
 */
DlDateAdapterMoment = /** @class */ (function (_super) {
    __extends(DlDateAdapterMoment, _super);
    function DlDateAdapterMoment() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param milliseconds
     *  a time value as milliseconds (local time zone)
     * @returns
     *  an instance of `moment` for the specified moment in time.
     */
    /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param {?} milliseconds
     *  a time value as milliseconds (local time zone)
     * @return {?}
     *  an instance of `moment` for the specified moment in time.
     */
    DlDateAdapterMoment.prototype.fromMilliseconds = /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param {?} milliseconds
     *  a time value as milliseconds (local time zone)
     * @return {?}
     *  an instance of `moment` for the specified moment in time.
     */
    function (milliseconds) {
        return moment(milliseconds);
    };
    /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param value
     *  a moment or `null`.
     * @returns
     *  a `moment.valueOf()` result for the specified `moment` or `null`
     */
    /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param {?} value
     *  a moment or `null`.
     * @return {?}
     *  a `moment.valueOf()` result for the specified `moment` or `null`
     */
    DlDateAdapterMoment.prototype.toMilliseconds = /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param {?} value
     *  a moment or `null`.
     * @return {?}
     *  a `moment.valueOf()` result for the specified `moment` or `null`
     */
    function (value) {
        return (value) ? value.valueOf() : undefined;
    };
    return DlDateAdapterMoment;
}(DlDateAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adapts `Date` to be usable as a date by date/time components that work with dates.
 *
 */
var  /**
 * Adapts `Date` to be usable as a date by date/time components that work with dates.
 *
 */
DlDateAdapterNative = /** @class */ (function (_super) {
    __extends(DlDateAdapterNative, _super);
    function DlDateAdapterNative() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param milliseconds
     *  a time value as milliseconds (local time zone)
     * @returns
     *  an instance of `moment` for the specified moment in time.
     */
    /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param {?} milliseconds
     *  a time value as milliseconds (local time zone)
     * @return {?}
     *  an instance of `moment` for the specified moment in time.
     */
    DlDateAdapterNative.prototype.fromMilliseconds = /**
     * Create a new instance of a `moment` type from milliseconds.
     * @param {?} milliseconds
     *  a time value as milliseconds (local time zone)
     * @return {?}
     *  an instance of `moment` for the specified moment in time.
     */
    function (milliseconds) {
        return new Date(milliseconds);
    };
    /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param value
     *  a Date or null.
     * @returns
     *  a `value.getTime()` result for the specified `Date` or `null`.
     */
    /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param {?} value
     *  a Date or null.
     * @return {?}
     *  a `value.getTime()` result for the specified `Date` or `null`.
     */
    DlDateAdapterNative.prototype.toMilliseconds = /**
     * Returns a moment in time value as milliseconds (local time zone).
     * @param {?} value
     *  a Date or null.
     * @return {?}
     *  a `value.getTime()` result for the specified `Date` or `null`.
     */
    function (value) {
        return (value) ? value.getTime() : undefined;
    };
    return DlDateAdapterNative;
}(DlDateAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Adapts `number` to be usable as a date by date/time components that work with dates.
 * No op adapter.
 *
 */
var  /**
 * Adapts `number` to be usable as a date by date/time components that work with dates.
 * No op adapter.
 *
 */
DlDateAdapterNumber = /** @class */ (function (_super) {
    __extends(DlDateAdapterNumber, _super);
    function DlDateAdapterNumber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the specified number.
     * @param milliseconds
     *  a moment time time.
     * @returns
     *  the specified moment in time.
     */
    /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    DlDateAdapterNumber.prototype.fromMilliseconds = /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    function (milliseconds) {
        return milliseconds;
    };
    /**
     * Returns the specified number.
     * @param value
     *  a moment time time or `null`
     * @returns
     *  the specified moment in time or `null`
     */
    /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the specified moment in time or `null`
     */
    DlDateAdapterNumber.prototype.toMilliseconds = /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the specified moment in time or `null`
     */
    function (value) {
        return value;
    };
    return DlDateAdapterNumber;
}(DlDateAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
var moment$1 = _moment;
/* istanbul ignore if */
if ('default' in _moment) {
    moment$1 = _moment__default;
}
/**
 * InjectionToken for string dates that can be used to override default model format.
 *
 * @type {?}
 */
var DL_DATE_TIME_DISPLAY_FORMAT = new InjectionToken('DL_DATE_TIME_DISPLAY_FORMAT');
/**
 * `Moment`'s long date format `lll` used as the default output format
 * for string date's
 * @type {?}
 */
var DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT = moment$1.localeData().longDateFormat('lll');
/**
 * InjectionToken for string dates that can be used to override default input formats.
 *
 * @type {?}
 */
var DL_DATE_TIME_INPUT_FORMATS = new InjectionToken('DL_DATE__TIME_INPUT_FORMATS');
/**
 *  Default input format's used by `DlDateAdapterString`
 * @type {?}
 */
var DL_DATE_TIME_INPUT_FORMATS_DEFAULT = [
    'YYYY-MM-DDTHH:mm',
    'YYYY-MM-DDTHH:mm:ss',
    'YYYY-MM-DDTHH:mm:ss.SSS',
    'YYYY-MM-DD',
    'M/D/YYYY h:m:s A',
    'M/D/YYYY h:m A',
    'M/D/YYYY h:m A',
    'M/D/YYYY',
    'M/D/YY h:m:s A',
    'M/D/YY h:m A',
    'M/D/YY h A',
    'M/D/YY',
    DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT,
    moment$1.ISO_8601,
];
/**
 * InjectionToken for string dates that can be used to override default model format.
 *
 * @type {?}
 */
var DL_DATE_TIME_MODEL_FORMAT = new InjectionToken('DL_DATE_TIME_MODEL_FORMAT');
/**
 *  Default model format (ISO 8601)`
 * @type {?}
 */
var DL_DATE_TIME_MODEL_FORMAT_DEFAULT = 'YYYY-MM-DDTHH:mm:ss.SSSZ';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 *
 * @type {?}
 */
var moment$2 = _moment;
/**
 * Adapts `string` to be usable as a date by date/time components that work with dates.
 *
 */
var DlDateAdapterString = /** @class */ (function (_super) {
    __extends(DlDateAdapterString, _super);
    /**
     *  Constructs a new instance of this class.
     *
     * @param inputFormats
     *  see {@link DL_DATE_TIME_INPUT_FORMATS}
     * @param modelFormat
     *  see {@link DL_DATE_TIME_MODEL_FORMAT}
     */
    function DlDateAdapterString(inputFormats, modelFormat) {
        var _this = _super.call(this) || this;
        _this.inputFormats = inputFormats;
        _this.modelFormat = modelFormat;
        return _this;
    }
    /**
     * Returns the specified number.
     * @param milliseconds
     *  a moment time time.
     * @returns
     *  the specified moment in time.
     */
    /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    DlDateAdapterString.prototype.fromMilliseconds = /**
     * Returns the specified number.
     * @param {?} milliseconds
     *  a moment time time.
     * @return {?}
     *  the specified moment in time.
     */
    function (milliseconds) {
        return moment$2(milliseconds).format(this.modelFormat);
    };
    /**
     * Returns the specified number.
     * @param value
     *  a moment time time or `null`
     * @returns
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    DlDateAdapterString.prototype.toMilliseconds = /**
     * Returns the specified number.
     * @param {?} value
     *  a moment time time or `null`
     * @return {?}
     *  the milliseconds for the specified value or `null`
     *  `null` is returned when value is not a valid input date string
     */
    function (value) {
        if (value !== undefined && value !== null) {
            /** @type {?} */
            var newMoment = moment$2(value, this.inputFormats, true);
            return newMoment.isValid() ? newMoment.valueOf() : undefined;
        }
    };
    /** @nocollapse */
    DlDateAdapterString.ctorParameters = function () { return [
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_MODEL_FORMAT,] }] }
    ]; };
    return DlDateAdapterString;
}(DlDateAdapter));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
var ɵ0 = DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT, ɵ1 = DL_DATE_TIME_INPUT_FORMATS_DEFAULT, ɵ2 = DL_DATE_TIME_MODEL_FORMAT_DEFAULT;
/**
 * Import this module to supply your own `DateAdapter` provider.
 * \@internal
 *
 */
var DlDateTimeCoreModule = /** @class */ (function () {
    function DlDateTimeCoreModule() {
    }
    DlDateTimeCoreModule.decorators = [
        { type: NgModule, args: [{
                    providers: [
                        { provide: DL_DATE_TIME_DISPLAY_FORMAT, useValue: ɵ0 },
                        { provide: DL_DATE_TIME_INPUT_FORMATS, useValue: ɵ1 },
                        { provide: DL_DATE_TIME_MODEL_FORMAT, useValue: ɵ2 }
                    ]
                },] }
    ];
    return DlDateTimeCoreModule;
}());
/**
 * Import this module to store `milliseconds` in the model.
 * \@internal
 */
var DlDateTimeNumberModule = /** @class */ (function () {
    function DlDateTimeNumberModule() {
    }
    DlDateTimeNumberModule.decorators = [
        { type: NgModule, args: [{
                    imports: [DlDateTimeCoreModule],
                    providers: [
                        { provide: DlDateAdapter, useClass: DlDateAdapterNumber }
                    ],
                    exports: [DlDateTimeCoreModule]
                },] }
    ];
    return DlDateTimeNumberModule;
}());
/**
 * Import this module to store a native JavaScript `Date` in the model.
 * \@internal
 */
var DlDateTimeDateModule = /** @class */ (function () {
    function DlDateTimeDateModule() {
    }
    DlDateTimeDateModule.decorators = [
        { type: NgModule, args: [{
                    imports: [DlDateTimeCoreModule],
                    providers: [
                        { provide: DlDateAdapter, useClass: DlDateAdapterNative }
                    ],
                },] }
    ];
    return DlDateTimeDateModule;
}());
/**
 * Import this module to store a `moment` in the model.
 * \@internal
 */
var DlDateTimeMomentModule = /** @class */ (function () {
    function DlDateTimeMomentModule() {
    }
    DlDateTimeMomentModule.decorators = [
        { type: NgModule, args: [{
                    imports: [DlDateTimeCoreModule],
                    providers: [
                        { provide: DlDateAdapter, useClass: DlDateAdapterMoment }
                    ],
                },] }
    ];
    return DlDateTimeMomentModule;
}());
var ɵ3 = DL_DATE_TIME_INPUT_FORMATS_DEFAULT, ɵ4 = DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT;
/**
 * Import this module to store a `string` in the model.
 * \@internal
 */
var DlDateTimeStringModule = /** @class */ (function () {
    function DlDateTimeStringModule() {
    }
    DlDateTimeStringModule.decorators = [
        { type: NgModule, args: [{
                    imports: [DlDateTimeCoreModule],
                    providers: [
                        { provide: DL_DATE_TIME_INPUT_FORMATS, useValue: ɵ3 },
                        { provide: DL_DATE_TIME_MODEL_FORMAT, useValue: ɵ4 },
                        { provide: DlDateAdapter, useClass: DlDateAdapterString }
                    ],
                },] }
    ];
    return DlDateTimeStringModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
/**
 * Emitted when the value of a date/time input changes.
 * @template D
 */
var  /**
 * Emitted when the value of a date/time input changes.
 * @template D
 */
DlDateTimeInputChange = /** @class */ (function () {
    /**
     * Constructs a new instance.
     * @param newValue
     *  the new value of the date/time picker.
     */
    function DlDateTimeInputChange(newValue) {
        this._value = newValue;
    }
    Object.defineProperty(DlDateTimeInputChange.prototype, "value", {
        /**
         * Get the new value of the date/time picker.
         * @returns the new value or null.
         */
        get: /**
         * Get the new value of the date/time picker.
         * @return {?} the new value or null.
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return DlDateTimeInputChange;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * \@internal
 * @type {?}
 */
var moment$3 = _moment;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 * @template D
 */
var DlDateTimeInputDirective = /** @class */ (function () {
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    function DlDateTimeInputDirective(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        var _this = this;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (/**
         * @param {?} control
         * @return {?}
         */
        function (control) {
            return (_this._inputFilter || ((/**
             * @return {?}
             */
            function () { return true; })))(_this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        });
        this._inputFilter = (/**
         * @return {?}
         */
        function () { return true; });
        this._isValid = true;
        this._parseValidator = (/**
         * @return {?}
         */
        function () {
            return _this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': _this._elementRef.nativeElement.value } };
        });
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._validatorOnChange = (/**
         * @return {?}
         */
        function () { });
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.dateChange = new EventEmitter();
    }
    Object.defineProperty(DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", {
        /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         */
        set: /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param {?} inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         * @return {?}
         */
        function (inputFilterFunction) {
            this._inputFilter = inputFilterFunction;
            this._validatorOnChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimeInputDirective.prototype, "value", {
        /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         **/
        get: /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         *
         * @return {?}
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emit a `change` event when the value of the input changes.
     */
    /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onChange = /**
     * Emit a `change` event when the value of the input changes.
     * @return {?}
     */
    function () {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    };
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onBlur = /**
     * Format the input text using {\@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     * @return {?}
     */
    function () {
        if (this._value) {
            this.writeValue(this._value);
        }
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) { return onTouched(); }));
    };
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    DlDateTimeInputDirective.prototype._onInput = /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {\@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param {?} value
     *   Value of the input control.
     * @return {?}
     */
    function (value) {
        var _this = this;
        /** @type {?} */
        var testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment$3(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this._value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        this._changed.forEach((/**
         * @param {?} onChanged
         * @return {?}
         */
        function (onChanged) { return onChanged(_this._value); }));
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnChange = /**
     * \@internal
     * @param {?} onChange
     * @return {?}
     */
    function (onChange) {
        this._changed.push(onChange);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnTouched = /**
     * \@internal
     * @param {?} onTouched
     * @return {?}
     */
    function (onTouched) {
        this._touched.push(onTouched);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.registerOnValidatorChange = /**
     * \@internal
     * @param {?} validatorOnChange
     * @return {?}
     */
    function (validatorOnChange) {
        this._validatorOnChange = validatorOnChange;
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.setDisabledState = /**
     * \@internal
     * @param {?} isDisabled
     * @return {?}
     */
    function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.validate = /**
     * \@internal
     * @param {?} control
     * @return {?}
     */
    function (control) {
        return this._validator(control);
    };
    /**
     * @internal
     */
    /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    DlDateTimeInputDirective.prototype.writeValue = /**
     * \@internal
     * @param {?} value
     * @return {?}
     */
    function (value) {
        /** @type {?} */
        var normalizedValue = value === null || value === undefined
            ? ''
            : moment$3(value).format(this._displayFormat);
        this._renderer.setProperty(this._elementRef.nativeElement, 'value', normalizedValue);
    };
    DlDateTimeInputDirective.decorators = [
        { type: Directive, args: [{
                    selector: 'input[dlDateTimeInput]',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef((/**
                             * @return {?}
                             */
                            function () { return DlDateTimeInputDirective; })), multi: true }
                    ]
                },] }
    ];
    /** @nocollapse */
    DlDateTimeInputDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: DlDateAdapter },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
    ]; };
    DlDateTimeInputDirective.propDecorators = {
        dateChange: [{ type: Output }],
        dlDateTimeInputFilter: [{ type: Input }],
        _onChange: [{ type: HostListener, args: ['change',] }],
        _onBlur: [{ type: HostListener, args: ['blur',] }],
        _onInput: [{ type: HostListener, args: ['input', ['$event.target.value'],] }]
    };
    return DlDateTimeInputDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Import this module to allow date/time input.
 * \@internal
 *
 */
var DlDateTimeInputModule = /** @class */ (function () {
    function DlDateTimeInputModule() {
    }
    DlDateTimeInputModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [DlDateTimeInputDirective],
                    imports: [CommonModule],
                    exports: [DlDateTimeInputDirective],
                },] }
    ];
    return DlDateTimeInputModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
/**
 * Emitted when the value of a date/time picker changes.
 * @template D
 */
var  /**
 * Emitted when the value of a date/time picker changes.
 * @template D
 */
DlDateTimePickerChange = /** @class */ (function () {
    /**
     * Constructs a new instance.
     * @param newValue
     *  the new value of the date/time picker.
     */
    function DlDateTimePickerChange(newValue) {
        this._value = newValue;
    }
    Object.defineProperty(DlDateTimePickerChange.prototype, "value", {
        /**
         * Get the new value of the date/time picker.
         * @returns the new value or null.
         */
        get: /**
         * Get the new value of the date/time picker.
         * @return {?} the new value or null.
         */
        function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    return DlDateTimePickerChange;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$4 = _moment;
/**
 * Default implementation for the `day` view.
 */
var  /**
 * Default implementation for the `day` view.
 */
DlDayModelProvider = /** @class */ (function () {
    function DlDayModelProvider() {
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlDayModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param milliseconds
     *  the moment in time from which the minute model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlDayModelProvider.prototype.getModel = /**
     * Returns the `day` model for the specified moment in `local` time with the
     * `active` day set to the first day of the month.
     *
     * The `day` model represents a month (42 days) as six rows with seven columns
     * and each cell representing one-day increments.
     *
     * The `day` always starts at midnight.
     *
     * Each cell represents a one-day increment at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var startOfMonth = moment$4(milliseconds).startOf('month');
        /** @type {?} */
        var endOfMonth = moment$4(milliseconds).endOf('month');
        /** @type {?} */
        var startOfView = moment$4(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
        /** @type {?} */
        var rowNumbers = [0, 1, 2, 3, 4, 5];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3, 4, 5, 6];
        /** @type {?} */
        var previousMonth = moment$4(startOfMonth).subtract(1, 'month');
        /** @type {?} */
        var nextMonth = moment$4(startOfMonth).add(1, 'month');
        /** @type {?} */
        var activeValue = moment$4(milliseconds).startOf('day').valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$4(selectedMilliseconds).startOf('day').valueOf();
        return {
            viewName: 'day',
            viewLabel: startOfMonth.format('MMM YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousMonth.valueOf(),
                ariaLabel: "Go to " + previousMonth.format('MMM YYYY'),
                classes: {},
            },
            upButton: {
                value: startOfMonth.valueOf(),
                ariaLabel: "Go to month view",
                classes: {},
            },
            rightButton: {
                value: nextMonth.valueOf(),
                ariaLabel: "Go to " + nextMonth.format('MMM YYYY'),
                classes: {},
            },
            rowLabels: columnNumbers.map((/**
             * @param {?} column
             * @return {?}
             */
            function (column) { return moment$4().weekday(column).format('dd'); })),
            rows: rowNumbers.map(rowOfDays)
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfDays(rowNumber) {
            /** @type {?} */
            var currentMoment = moment$4();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var dayMoment = moment$4(startOfView).add((rowNumber * columnNumbers.length) + columnNumber, 'days');
                return {
                    display: dayMoment.format('D'),
                    ariaLabel: dayMoment.format('ll'),
                    value: dayMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === dayMoment.valueOf(),
                        'dl-abdtp-future': dayMoment.isAfter(endOfMonth),
                        'dl-abdtp-past': dayMoment.isBefore(startOfMonth),
                        'dl-abdtp-selected': selectedValue === dayMoment.valueOf(),
                        'dl-abdtp-now': dayMoment.isSame(currentMoment, 'day'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    DlDayModelProvider.prototype.goDown = /**
     * Move the active `day` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(7, 'days').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    DlDayModelProvider.prototype.goUp = /**
     * Move the active `day` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(7, 'days').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    DlDayModelProvider.prototype.goLeft = /**
     * Move the `active` day one cell `left` in the current `day` view.
     *
     * Moving `left` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    DlDayModelProvider.prototype.goRight = /**
     * Move the `active` day one cell `right` in the current `day` view.
     *
     * Moving `right` can result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`, in this case the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `day` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    DlDayModelProvider.prototype.pageDown = /**
     * Move the active `day` one month `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    DlDayModelProvider.prototype.pageUp = /**
     * Move the active `day` one month `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` day being part of a different month than
     * the specified `fromMilliseconds`. As a result, the month represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `day` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `day` one month `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the last cell in the view as the active `day`.
     */
    /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `day`.
     */
    DlDayModelProvider.prototype.goEnd = /**
     * Move the `active` `day` to the last day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `day`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds)
            .endOf('month').startOf('day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the first cell in the view as the active `day`.
     */
    /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `day`.
     */
    DlDayModelProvider.prototype.goHome = /**
     * Move the `active` `day` to the first day of the month.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first day of the month will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `day`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$4(fromMilliseconds).startOf('month').valueOf(), selectedMilliseconds);
    };
    return DlDayModelProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$5 = _moment;
/**
 * Default implementation for the `hour` view.
 */
var  /**
 * Default implementation for the `hour` view.
 */
DlHourModelProvider = /** @class */ (function () {
    function DlHourModelProvider() {
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlHourModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `hour` model for the specified moment in `local` time with the
     * `active` hour set to the beginning of the day.
     *
     * The `hour` model represents a day (24 hours) as six rows with four columns
     * and each cell representing one-hour increments.
     *
     * The hour always starts at the beginning of the hour.
     *
     * Each cell represents a one-hour increment starting at midnight.
     *
     * @param milliseconds
     *  the moment in time from which the minute model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `hour` model for the specified moment in `local` time with the
     * `active` hour set to the beginning of the day.
     *
     * The `hour` model represents a day (24 hours) as six rows with four columns
     * and each cell representing one-hour increments.
     *
     * The hour always starts at the beginning of the hour.
     *
     * Each cell represents a one-hour increment starting at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlHourModelProvider.prototype.getModel = /**
     * Returns the `hour` model for the specified moment in `local` time with the
     * `active` hour set to the beginning of the day.
     *
     * The `hour` model represents a day (24 hours) as six rows with four columns
     * and each cell representing one-hour increments.
     *
     * The hour always starts at the beginning of the hour.
     *
     * Each cell represents a one-hour increment starting at midnight.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var startDate = moment$5(milliseconds).startOf('day');
        /** @type {?} */
        var rowNumbers = [0, 1, 2, 3, 4, 5];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3];
        /** @type {?} */
        var previousDay = moment$5(startDate).subtract(1, 'day');
        /** @type {?} */
        var nextDay = moment$5(startDate).add(1, 'day');
        /** @type {?} */
        var activeValue = moment$5(milliseconds).startOf('hour').valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$5(selectedMilliseconds).startOf('hour').valueOf();
        return {
            viewName: 'hour',
            viewLabel: startDate.format('ll'),
            activeDate: activeValue,
            leftButton: {
                value: previousDay.valueOf(),
                ariaLabel: "Go to " + previousDay.format('ll'),
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: "Go to " + startDate.format('MMM YYYY'),
                classes: {},
            },
            rightButton: {
                value: nextDay.valueOf(),
                ariaLabel: "Go to " + nextDay.format('ll'),
                classes: {},
            },
            rows: rowNumbers.map(rowOfHours)
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfHours(rowNumber) {
            /** @type {?} */
            var currentMoment = moment$5();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var hourMoment = moment$5(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'hours');
                return {
                    display: hourMoment.format('LT'),
                    ariaLabel: hourMoment.format('LLL'),
                    value: hourMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === hourMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === hourMoment.valueOf(),
                        'dl-abdtp-now': hourMoment.isSame(currentMoment, 'hour'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `hour` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `hour` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one row `down` from the specified moment in time.
     */
    DlHourModelProvider.prototype.goDown = /**
     * Move the active `hour` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(4, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `hour` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one row `up` from the specified moment in time.
     */
    DlHourModelProvider.prototype.goUp = /**
     * Move the active `hour` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(4, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` hour one cell `left` in the current `hour` view.
     *
     * Moving `left` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `hour` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one cell to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` hour one cell `left` in the current `hour` view.
     *
     * Moving `left` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `hour` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one cell to the `left` of the specified moment in time.
     */
    DlHourModelProvider.prototype.goLeft = /**
     * Move the `active` hour one cell `left` in the current `hour` view.
     *
     * Moving `left` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `hour` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one cell to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` hour one cell `right` in the current `hour` view.
     *
     * Moving `right` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `hour` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one cell to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` hour one cell `right` in the current `hour` view.
     *
     * Moving `right` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `hour` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one cell to the `right` of the specified moment in time.
     */
    DlHourModelProvider.prototype.goRight = /**
     * Move the `active` hour one cell `right` in the current `hour` view.
     *
     * Moving `right` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `hour` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one cell to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one day `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one day `down` from the specified moment in time.
     */
    /**
     * Move the active `hour` one day `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one day `down` from the specified moment in time.
     */
    DlHourModelProvider.prototype.pageDown = /**
     * Move the active `hour` one day `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one day `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one day `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one day `up` from the specified moment in time.
     */
    /**
     * Move the active `hour` one day `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one day `up` from the specified moment in time.
     */
    DlHourModelProvider.prototype.pageUp = /**
     * Move the active `hour` one day `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `hour` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `hour` one day `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `hour` to `11:00 pm` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `11:00 pm` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `11:00 pm` cell in the view as the active `hour`.
     */
    /**
     * Move the `active` `hour` to `11:00 pm` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `11:00 pm` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `11:00 pm` cell in the view as the active `hour`.
     */
    DlHourModelProvider.prototype.goEnd = /**
     * Move the `active` `hour` to `11:00 pm` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `11:00 pm` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `11:00 pm` cell in the view as the active `hour`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds)
            .endOf('day')
            .startOf('hour')
            .valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `hour` to `midnight` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `midnight` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `midnight` cell in the view as the active `hour`.
     */
    /**
     * Move the `active` `hour` to `midnight` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `midnight` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `midnight` cell in the view as the active `hour`.
     */
    DlHourModelProvider.prototype.goHome = /**
     * Move the `active` `hour` to `midnight` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `midnight` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `midnight` cell in the view as the active `hour`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$5(fromMilliseconds).startOf('day').valueOf(), selectedMilliseconds);
    };
    return DlHourModelProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$6 = _moment;
/**
 * Default implementation for the `minute` view.
 */
var  /**
 * Default implementation for the `minute` view.
 */
DlMinuteModelProvider = /** @class */ (function () {
    function DlMinuteModelProvider() {
        this.step = 5;
    }
    /**
     * Receives `minuteStep` configuration changes detected by Angular.
     *
     * Changes where the value has not changed are ignored.
     *
     * Setting `minuteStep` to `null` or `undefined` will result in a
     * minuteStep of `5`.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives `minuteStep` configuration changes detected by Angular.
     *
     * Changes where the value has not changed are ignored.
     *
     * Setting `minuteStep` to `null` or `undefined` will result in a
     * minuteStep of `5`.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlMinuteModelProvider.prototype.onChanges = /**
     * Receives `minuteStep` configuration changes detected by Angular.
     *
     * Changes where the value has not changed are ignored.
     *
     * Setting `minuteStep` to `null` or `undefined` will result in a
     * minuteStep of `5`.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var minuteStepChange = changes['minuteStep'];
        if (minuteStepChange
            && (minuteStepChange.previousValue !== minuteStepChange.currentValue)) {
            this.step = minuteStepChange.currentValue;
            if (this.step === null || this.step === undefined) {
                this.step = 5;
            }
        }
    };
    /**
     * Returns the `minute` model for the specified moment in `local` time with the
     * `active` minute set to the beginning of the hour.
     *
     * The `minute` model represents an hour (60 minutes) as three rows with four columns
     * and each cell representing 5-minute increments.
     *
     * The hour always starts at midnight.
     *
     * Each cell represents a 5-minute increment starting at midnight.
     *
     * The `active` minute will be the 5-minute increments less than or equal to the specified milliseconds.
     *
     * @param milliseconds
     *  the moment in time from which the minute model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `minute` model for the specified moment in `local` time with the
     * `active` minute set to the beginning of the hour.
     *
     * The `minute` model represents an hour (60 minutes) as three rows with four columns
     * and each cell representing 5-minute increments.
     *
     * The hour always starts at midnight.
     *
     * Each cell represents a 5-minute increment starting at midnight.
     *
     * The `active` minute will be the 5-minute increments less than or equal to the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlMinuteModelProvider.prototype.getModel = /**
     * Returns the `minute` model for the specified moment in `local` time with the
     * `active` minute set to the beginning of the hour.
     *
     * The `minute` model represents an hour (60 minutes) as three rows with four columns
     * and each cell representing 5-minute increments.
     *
     * The hour always starts at midnight.
     *
     * Each cell represents a 5-minute increment starting at midnight.
     *
     * The `active` minute will be the 5-minute increments less than or equal to the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the minute model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        var _this = this;
        /** @type {?} */
        var startDate = moment$6(milliseconds).startOf('hour');
        /** @type {?} */
        var currentMilliseconds = moment$6().valueOf();
        /** @type {?} */
        var minuteSteps = new Array(Math.ceil(60 / this.step)).fill(0).map((/**
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        function (value, index) { return index * _this.step; }));
        /** @type {?} */
        var minuteValues = minuteSteps.map((/**
         * @param {?} minutesToAdd
         * @return {?}
         */
        function (minutesToAdd) { return moment$6(startDate).add(minutesToAdd, 'minutes').valueOf(); }));
        /** @type {?} */
        var activeValue = moment$6(minuteValues.filter((/**
         * @param {?} value
         * @return {?}
         */
        function (value) { return value <= milliseconds; })).pop()).valueOf();
        /** @type {?} */
        var nowValue = currentMilliseconds >= startDate.valueOf() && currentMilliseconds <= moment$6(startDate).endOf('hour').valueOf()
            ? moment$6(minuteValues.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value <= currentMilliseconds; })).pop()).valueOf()
            : null;
        /** @type {?} */
        var previousHour = moment$6(startDate).subtract(1, 'hour');
        /** @type {?} */
        var nextHour = moment$6(startDate).add(1, 'hour');
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$6(minuteValues.filter((/**
             * @param {?} value
             * @return {?}
             */
            function (value) { return value <= selectedMilliseconds; })).pop()).valueOf();
        /** @type {?} */
        var rows = new Array(Math.ceil(minuteSteps.length / 4))
            .fill(0)
            .map((/**
         * @param {?} value
         * @param {?} index
         * @return {?}
         */
        function (value, index) { return index; }))
            .map((/**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            return { cells: minuteSteps.slice((value * 4), (value * 4) + 4).map(rowOfMinutes) };
        }));
        return {
            viewName: 'minute',
            viewLabel: startDate.format('lll'),
            activeDate: activeValue,
            leftButton: {
                value: previousHour.valueOf(),
                ariaLabel: "Go to " + previousHour.format('lll'),
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: "Go to " + startDate.format('ll'),
                classes: {},
            },
            rightButton: {
                value: nextHour.valueOf(),
                ariaLabel: "Go to " + nextHour.format('lll'),
                classes: {},
            },
            rows: rows
        };
        /**
         * @param {?} stepMinutes
         * @return {?}
         */
        function rowOfMinutes(stepMinutes) {
            /** @type {?} */
            var minuteMoment = moment$6(startDate).add(stepMinutes, 'minutes');
            return {
                display: minuteMoment.format('LT'),
                ariaLabel: minuteMoment.format('LLL'),
                value: minuteMoment.valueOf(),
                classes: {
                    'dl-abdtp-active': activeValue === minuteMoment.valueOf(),
                    'dl-abdtp-selected': selectedValue === minuteMoment.valueOf(),
                    'dl-abdtp-now': nowValue === minuteMoment.valueOf(),
                }
            };
        }
    };
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    DlMinuteModelProvider.prototype.goDown = /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    DlMinuteModelProvider.prototype.goUp = /**
     * Move the active `minute` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` minute being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `minute` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` date one cell to `left` in the current `minute` view.
     *
     * Moving `left` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `minute` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `minute` one cell to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` date one cell to `left` in the current `minute` view.
     *
     * Moving `left` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `left` of the specified moment in time.
     */
    DlMinuteModelProvider.prototype.goLeft = /**
     * Move the `active` date one cell to `left` in the current `minute` view.
     *
     * Moving `left` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(this.step, 'minutes').valueOf(), selectedMilliseconds);
    };
    /**
     * Move `active` minute one cell to `right` in the current `minute` view.
     *
     * Moving `right` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `minute` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `minute` one cell to the `right` of the specified moment in time.
     */
    /**
     * Move `active` minute one cell to `right` in the current `minute` view.
     *
     * Moving `right` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `right` of the specified moment in time.
     */
    DlMinuteModelProvider.prototype.goRight = /**
     * Move `active` minute one cell to `right` in the current `minute` view.
     *
     * Moving `right` can result in the `active` hour being part of a different hour than
     * the specified `fromMilliseconds`, in this case the hour represented by the model
     * will change to show the correct hour.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `minute` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `minute` one cell to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(this.step, 'minutes').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `minute` one hour `down` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-down` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    /**
     * Move the active `minute` one hour `down` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-down` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    DlMinuteModelProvider.prototype.pageDown = /**
     * Move the active `minute` one hour `down` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-down` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `minute` one hour `up` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour before` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-up` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    /**
     * Move the active `minute` one hour `up` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour before` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-up` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    DlMinuteModelProvider.prototype.pageUp = /**
     * Move the active `minute` one hour `up` from the specified moment in time.
     *
     * The `active` minute will be `one (1) hour before` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `minute` view.
     *
     * The next cell `page-up` will be in a different hour than the currently
     * displayed view and the model time range will include the new active cell.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `minute` to the last cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the last cell will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the last cell in the view as the active `minute`.
     */
    /**
     * Move the `active` `minute` to the last cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `minute`.
     */
    DlMinuteModelProvider.prototype.goEnd = /**
     * Move the `active` `minute` to the last cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the last cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the last cell in the view as the active `minute`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds)
            .endOf('hour')
            .valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `minute` to the first cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the first cell will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the first cell in the view as the active `minute`.
     */
    /**
     * Move the `active` `minute` to the first cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `minute`.
     */
    DlMinuteModelProvider.prototype.goHome = /**
     * Move the `active` `minute` to the first cell of the current hour.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different hour than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the first cell will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the first cell in the view as the active `minute`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$6(fromMilliseconds).startOf('hour').valueOf(), selectedMilliseconds);
    };
    return DlMinuteModelProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$7 = _moment;
/**
 * Default implementation for the `month` view.
 */
var  /**
 * Default implementation for the `month` view.
 */
DlMonthModelProvider = /** @class */ (function () {
    function DlMonthModelProvider() {
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlMonthModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `month` model for the specified moment in `local` time with the
     * `active` month set to the first day of the specified month.
     *
     * The `month` model represents a year (12 months) as three rows with four columns.
     *
     * The year always starts in January.
     *
     * Each cell represents midnight on the 1st day of the month.
     *
     * The `active` month will be the January of year of the specified milliseconds.
     *
     * @param milliseconds
     *  the moment in time from which the month model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `month` model for the specified moment in `local` time with the
     * `active` month set to the first day of the specified month.
     *
     * The `month` model represents a year (12 months) as three rows with four columns.
     *
     * The year always starts in January.
     *
     * Each cell represents midnight on the 1st day of the month.
     *
     * The `active` month will be the January of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the month model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlMonthModelProvider.prototype.getModel = /**
     * Returns the `month` model for the specified moment in `local` time with the
     * `active` month set to the first day of the specified month.
     *
     * The `month` model represents a year (12 months) as three rows with four columns.
     *
     * The year always starts in January.
     *
     * Each cell represents midnight on the 1st day of the month.
     *
     * The `active` month will be the January of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the month model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var startDate = moment$7(milliseconds).startOf('year');
        /** @type {?} */
        var rowNumbers = [0, 1, 2];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3];
        /** @type {?} */
        var previousYear = moment$7(startDate).subtract(1, 'year');
        /** @type {?} */
        var nextYear = moment$7(startDate).add(1, 'year');
        /** @type {?} */
        var activeValue = moment$7(milliseconds).startOf('month').valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$7(selectedMilliseconds).startOf('month').valueOf();
        return {
            viewName: 'month',
            viewLabel: startDate.format('YYYY'),
            activeDate: activeValue,
            leftButton: {
                value: previousYear.valueOf(),
                ariaLabel: "Go to " + previousYear.format('YYYY'),
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: "Go to " + startDate.format('YYYY'),
                classes: {},
            },
            rightButton: {
                value: nextYear.valueOf(),
                ariaLabel: "Go to " + nextYear.format('YYYY'),
                classes: {},
            },
            rows: rowNumbers.map(rowOfMonths)
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfMonths(rowNumber) {
            /** @type {?} */
            var currentMoment = moment$7();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var monthMoment = moment$7(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'months');
                return {
                    display: monthMoment.format('MMM'),
                    ariaLabel: monthMoment.format('MMM YYYY'),
                    value: monthMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === monthMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === monthMoment.valueOf(),
                        'dl-abdtp-now': monthMoment.isSame(currentMoment, 'month'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `month` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `month` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one row `down` from the specified moment in time.
     */
    DlMonthModelProvider.prototype.goDown = /**
     * Move the active `month` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).add(4, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `month` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the previous `month` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `month` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `month` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one row `up` from the specified moment in time.
     */
    DlMonthModelProvider.prototype.goUp = /**
     * Move the active `month` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `month` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).subtract(4, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `month` one (1) month to the `left` of the specified moment in time.
     *
     * Moving `left` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `month` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one month to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` `month` one (1) month to the `left` of the specified moment in time.
     *
     * Moving `left` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `month` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one month to the `left` of the specified moment in time.
     */
    DlMonthModelProvider.prototype.goLeft = /**
     * Move the `active` `month` one (1) month to the `left` of the specified moment in time.
     *
     * Moving `left` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `month` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one month to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `month` one (1) month to the `right` of the specified moment in time.
     *
     * The `active` month will be `one (1) month after` the specified milliseconds.
     * This moves the `active` date one month `right` in the current `month` view.
     *
     * Moving `right` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `month` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` `month` one (1) month to the `right` of the specified moment in time.
     *
     * The `active` month will be `one (1) month after` the specified milliseconds.
     * This moves the `active` date one month `right` in the current `month` view.
     *
     * Moving `right` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `month` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year to the `right` of the specified moment in time.
     */
    DlMonthModelProvider.prototype.goRight = /**
     * Move the `active` `month` one (1) month to the `right` of the specified moment in time.
     *
     * The `active` month will be `one (1) month after` the specified milliseconds.
     * This moves the `active` date one month `right` in the current `month` view.
     *
     * Moving `right` can result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`, in this case the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `month` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    DlMonthModelProvider.prototype.pageDown = /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).add(12, 'months').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `up` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `month` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `month` one year `up` from the specified moment in time.
     */
    /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `up` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `up` from the specified moment in time.
     */
    DlMonthModelProvider.prototype.pageUp = /**
     * Move the active `month` one year `down` from the specified moment in time.
     *
     * Paging `up` will result in the `active` month being part of a different year than
     * the specified `fromMilliseconds`. As a result, the year represented by the model
     * will change to show the correct year.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `month` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `month` one year `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).subtract(12, 'months').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `month` to `December` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `December 1` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `December` cell in the view as the active `month`.
     */
    /**
     * Move the `active` `month` to `December` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `December 1` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `December` cell in the view as the active `month`.
     */
    DlMonthModelProvider.prototype.goEnd = /**
     * Move the `active` `month` to `December` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `December 1` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `December` cell in the view as the active `month`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).endOf('year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `month` to `January` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `January 1` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `January` cell in the view as the active `month`.
     */
    /**
     * Move the `active` `month` to `January` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `January 1` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `January` cell in the view as the active `month`.
     */
    DlMonthModelProvider.prototype.goHome = /**
     * Move the `active` `month` to `January` of the current year.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different year than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which `January 1` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `January` cell in the view as the active `month`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$7(fromMilliseconds).startOf('year').valueOf(), selectedMilliseconds);
    };
    return DlMonthModelProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$8 = _moment;
/**
 * Default implementation for the `year` view.
 */
var  /**
 * Default implementation for the `year` view.
 */
DlYearModelProvider = /** @class */ (function () {
    function DlYearModelProvider() {
    }
    /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * @param fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @returns
     *  moment at midnight january 1 at the start of the current decade.
     * @internal
     */
    /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * \@internal
     * @private
     * @param {?} fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @return {?}
     *  moment at midnight january 1 at the start of the current decade.
     */
    DlYearModelProvider.getStartOfDecade = /**
     * Create a moment at midnight january 1 at the start of the current decade.
     * The start of the decade is always a year ending in zero.
     *
     * \@internal
     * @private
     * @param {?} fromMilliseconds
     *  the moment in time from which the start of the decade will be determined.
     * @return {?}
     *  moment at midnight january 1 at the start of the current decade.
     */
    function (fromMilliseconds) {
        // Truncate the last digit from the current year to get the start of the decade
        /** @type {?} */
        var startDecade = (Math.trunc(moment$8(fromMilliseconds).year() / 10) * 10);
        return moment$8({ year: startDecade }).startOf('year');
    };
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlYearModelProvider.prototype.onChanges = /**
     * Receives input changes detected by Angular.
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
    };
    /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param milliseconds
     *  the moment in time from which the year model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the year model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    DlYearModelProvider.prototype.getModel = /**
     * Returns the `year` model for the specified moment in `local` time with the
     * `active` year set to January 1 of the specified year.
     *
     * The `year` model represents a decade (10 years) as two rows with five columns.
     *
     * The decade always starts on a year ending with zero.
     *
     * Each cell represents midnight January 1 of the indicated year.
     *
     * The `active` year will be the January 1 of year of the specified milliseconds.
     *
     * @param {?} milliseconds
     *  the moment in time from which the year model will be created.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  the model representing the specified moment in time.
     */
    function (milliseconds, selectedMilliseconds) {
        /** @type {?} */
        var rowNumbers = [0, 1];
        /** @type {?} */
        var columnNumbers = [0, 1, 2, 3, 4];
        /** @type {?} */
        var startYear = moment$8(milliseconds).startOf('year');
        /** @type {?} */
        var startDate = DlYearModelProvider.getStartOfDecade(milliseconds);
        /** @type {?} */
        var futureYear = startDate.year() + 9;
        /** @type {?} */
        var pastYear = startDate.year();
        /** @type {?} */
        var activeValue = startYear.valueOf();
        /** @type {?} */
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment$8(selectedMilliseconds).startOf('year').valueOf();
        return {
            viewName: 'year',
            viewLabel: pastYear + "-" + futureYear,
            activeDate: activeValue,
            leftButton: {
                value: moment$8(startDate).subtract(10, 'years').valueOf(),
                ariaLabel: "Go to " + (pastYear - 10) + "-" + (pastYear - 1),
                classes: {},
            },
            rightButton: {
                value: moment$8(startDate).add(10, 'years').valueOf(),
                ariaLabel: "Go to " + (futureYear + 1) + "-" + (futureYear + 10),
                classes: {},
            },
            rows: rowNumbers.map(rowOfYears.bind(this))
        };
        /**
         * @param {?} rowNumber
         * @return {?}
         */
        function rowOfYears(rowNumber) {
            /** @type {?} */
            var currentMoment = moment$8();
            /** @type {?} */
            var cells = columnNumbers.map((/**
             * @param {?} columnNumber
             * @return {?}
             */
            function (columnNumber) {
                /** @type {?} */
                var yearMoment = moment$8(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'years');
                return {
                    display: yearMoment.format('YYYY'),
                    value: yearMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === yearMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === yearMoment.valueOf(),
                        'dl-abdtp-now': yearMoment.isSame(currentMoment, 'year'),
                    }
                };
            }));
            return { cells: cells };
        }
    };
    /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    DlYearModelProvider.prototype.goDown = /**
     * Move the active `year` one row `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
     * This moves the `active` date one row `down` in the current `year` view.
     *
     * Moving `down` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).add(5, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    DlYearModelProvider.prototype.goUp = /**
     * Move the active `year` one row `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
     * This moves the `active` date one row `up` in the current `year` view.
     *
     * Moving `up` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the previous `year` model `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one row `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).subtract(5, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    DlYearModelProvider.prototype.goLeft = /**
     * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
     * This moves the `active` date one year `left` in the current `year` view.
     *
     * Moving `left` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `left` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `left` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).subtract(1, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    DlYearModelProvider.prototype.goRight = /**
     * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
     *
     * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
     * This moves the `active` date one year `right` in the current `year` view.
     *
     * Moving `right` can result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`, in this case the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `year` model to the `right` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one year to the `right` of the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).add(1, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    DlYearModelProvider.prototype.pageDown = /**
     * Move the active `year` one decade `down` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
     * This moves the `active` date one `page` `down` from the current `year` view.
     *
     * Paging `down` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `down` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `down` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).add(10, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    DlYearModelProvider.prototype.pageUp = /**
     * Move the active `year` one decade `up` from the specified moment in time.
     *
     * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
     * This moves the `active` date one `page-up` from the current `year` view.
     *
     * Paging `up` will result in the `active` year being part of a different decade than
     * the specified `fromMilliseconds`. As a result, the decade represented by the model
     * will change to show the correct decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the next `year` model page `up` will be constructed.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  model containing an `active` `year` one decade `up` from the specified moment in time.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment$8(fromMilliseconds).subtract(10, 'year').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `last` cell in the view as the active `year`.
     */
    /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `last` cell in the view as the active `year`.
     */
    DlYearModelProvider.prototype.goEnd = /**
     * Move the `active` `year` to the `last` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `last` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `last` cell in the view as the active `year`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .add(9, 'years')
            .endOf('year')
            .valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `first` cell in the view as the active `year`.
     */
    /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `first` cell in the view as the active `year`.
     */
    DlYearModelProvider.prototype.goHome = /**
     * Move the `active` `year` to the `first` year in the decade.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different decade than the displayed decade.
     *
     * @param {?} fromMilliseconds
     *  the moment in time from which the `first` active `year` will be calculated.
     * @param {?} selectedMilliseconds
     *  the current value of the date/time picker.
     * @return {?}
     *  a model with the `first` cell in the view as the active `year`.
     */
    function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
            .startOf('year')
            .valueOf(), selectedMilliseconds);
    };
    return DlYearModelProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * \@internal
 *
 * @type {?}
 */
var moment$9 = _moment;
/**
 * Maps key codes to the model provider function name
 * that should be called to perform the action.
 *
 * \@internal
 *
 * @type {?}
 */
var keyCodeToModelProviderMethod = {
    'ArrowDown': 'goDown',
    'ArrowLeft': 'goLeft',
    'ArrowRight': 'goRight',
    'ArrowUp': 'goUp',
    'Down': 'goDown',
    'End': 'goEnd',
    'Home': 'goHome',
    'Left': 'goLeft',
    'PageDown': 'pageDown',
    'PageUp': 'pageUp',
    'Right': 'goRight',
    'Up': 'goUp',
    33: 'pageUp',
    34: 'pageDown',
    35: 'goEnd',
    36: 'goHome',
    37: 'goLeft',
    38: 'goUp',
    39: 'goRight',
    40: 'goDown',
};
/**
 * List of view names for the calendar.
 *
 * This list must be in order from
 * smallest increment of time to largest increment of time.
 *
 * \@internal
 *
 * @type {?}
 */
var VIEWS = [
    'minute',
    'hour',
    'day',
    'month',
    'year'
];
/**
 * Component that provides all of the user facing functionality of the date/time picker.
 * @template D
 */
var DlDateTimePickerComponent = /** @class */ (function () {
    /**
     * Used to construct a new instance of a date/time picker.
     *
     * @param _elementRef
     *  reference to this element.
     * @param _ngZone
     *  reference to an NgZone instance used to select the active element outside of angular.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param yearModelComponent
     *  provider for the year view model.
     * @param monthModelComponent
     *  provider for the month view model.
     * @param dayModelComponent
     *  provider for the day view model.
     * @param hourModelComponent
     *  provider for the hour view model.
     * @param minuteModelComponent
     *  provider for the minute view model.
     */
    function DlDateTimePickerComponent(_elementRef, _ngZone, _dateAdapter, yearModelComponent, monthModelComponent, dayModelComponent, hourModelComponent, minuteModelComponent) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        this._dateAdapter = _dateAdapter;
        this.yearModelComponent = yearModelComponent;
        this.monthModelComponent = monthModelComponent;
        this.dayModelComponent = dayModelComponent;
        this.hourModelComponent = hourModelComponent;
        this.minuteModelComponent = minuteModelComponent;
        /**
         * Change listener callback functions registered
         * via `registerOnChange`
         * \@internal
         *
         */
        this._changed = [];
        /**
         * Maps view name to the next view (the view for the next smallest increment of time).
         * \@internal
         *
         */
        this._nextView = {
            'year': 'month',
            'month': 'day',
            'day': 'hour',
            'hour': 'minute'
        };
        /**
         * Maps view name to the previous view (the view for the next largest increment of time).
         * \@internal
         *
         */
        this._previousView = {
            'minute': 'hour',
            'hour': 'day',
            'day': 'month',
            'month': 'year'
        };
        /**
         * Touch listener callback functions registered
         * via `registerOnChange`
         * \@internal
         *
         */
        this._touched = [];
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         *
         */
        this.change = new EventEmitter();
        /**
         * Specifies the classes used to display the left icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.leftIconClass = [
            'oi',
            'oi-chevron-left'
        ];
        /**
         * The highest view that the date/time picker can show.
         * Setting this to a view less than year could make it more
         * difficult for the end-user to navigate to certain dates.
         */
        this.maxView = 'year';
        /**
         * The view that will be used for date/time selection.
         *
         * The default of `minute  means that selection will not happen
         * until the end-user clicks on a cell in the minute view.
         *
         * for example, if you want the end-user to select a only day (date),
         * setting `minView` to `day` will cause selection to happen when the
         * end-user selects a cell in the day view.
         *
         * NOTE: This must be set lower than or equal to `startView'
         */
        this.minView = 'minute';
        /**
         * The number of minutes between each `.dl-abdtp-minute` button.
         *
         * Must be greater than `0` and less than `60`.
         */
        this.minuteStep = 5;
        /**
         * Specifies the classes used to display the right icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.rightIconClass = [
            'oi',
            'oi-chevron-right'
        ];
        /* tslint:disable:member-ordering */
        /**
         *  Determine whether or not the `DateButton` is selectable by the end user.
         */
        this.selectFilter = (/**
         * @return {?}
         */
        function () { return true; });
        /**
         * The initial view that the date/time picker will show.
         * The picker will also return to this view after a date/time
         * is selected.
         *
         * NOTE: This must be set lower than or equal to `maxView'
         */
        this.startView = 'day';
        /**
         * Specifies the classes used to display the up icon.
         *
         * This component uses OPENICONIC https://useiconic.com/open
         * by default but any icon library may be used.
         */
        this.upIconClass = [
            'oi',
            'oi-chevron-top'
        ];
        this._viewToModelProvider = {
            year: yearModelComponent,
            month: monthModelComponent,
            day: dayModelComponent,
            hour: hourModelComponent,
            minute: minuteModelComponent,
        };
    }
    Object.defineProperty(DlDateTimePickerComponent.prototype, "model", {
        /* tslint:enable:member-ordering */
        /**
         * Set's the model for the current view after applying the selection filter.
         *
         * @internal
         **/
        set: /* tslint:enable:member-ordering */
        /**
         * Set's the model for the current view after applying the selection filter.
         *
         * \@internal
         *
         * @private
         * @param {?} model
         * @return {?}
         */
        function (model) {
            this._model = this.applySelectFilter(model);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimePickerComponent.prototype, "value", {
        /**
         * Returns `D` value of the date/time picker or undefined/null if no value is set.
         **/
        get: /**
         * Returns `D` value of the date/time picker or undefined/null if no value is set.
         *
         * @return {?}
         */
        function () {
            return this._value;
        },
        /**
         * Sets value of the date/time picker and emits a change event if the
         * new value is different from the previous value.
         **/
        set: /**
         * Sets value of the date/time picker and emits a change event if the
         * new value is different from the previous value.
         *
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (this._value !== value) {
                this._value = value;
                this.model = this._viewToModelProvider[this._model.viewName].getModel(this.getStartDate(), this.valueOf);
                this._changed.forEach((/**
                 * @param {?} f
                 * @return {?}
                 */
                function (f) { return f(value); }));
                this.change.emit(new DlDateTimePickerChange(value));
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimePickerComponent.prototype, "valueOf", {
        /**
         * Returns `milliseconds` value of the date/time picker or undefined/null if no value is set.
         **/
        get: /**
         * Returns `milliseconds` value of the date/time picker or undefined/null if no value is set.
         *
         * @return {?}
         */
        function () {
            return this._dateAdapter.toMilliseconds(this._value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Applies the `selectionFilter` by adding the `dl-abdtp-disabled`
     * class to any `DateButton` where `selectFilter` returned false.
     *
     * @param model
     *  the new model
     *
     * @returns
     *  the supplied model with zero or more `DateButton`'s
     *  having the `dl-abdtp-disabled` class set to `true` if the
     *  selection for that date should be disabled.
     *
     * @internal
     */
    /**
     * Applies the `selectionFilter` by adding the `dl-abdtp-disabled`
     * class to any `DateButton` where `selectFilter` returned false.
     *
     * \@internal
     * @private
     * @param {?} model
     *  the new model
     *
     * @return {?}
     *  the supplied model with zero or more `DateButton`'s
     *  having the `dl-abdtp-disabled` class set to `true` if the
     *  selection for that date should be disabled.
     *
     */
    DlDateTimePickerComponent.prototype.applySelectFilter = /**
     * Applies the `selectionFilter` by adding the `dl-abdtp-disabled`
     * class to any `DateButton` where `selectFilter` returned false.
     *
     * \@internal
     * @private
     * @param {?} model
     *  the new model
     *
     * @return {?}
     *  the supplied model with zero or more `DateButton`'s
     *  having the `dl-abdtp-disabled` class set to `true` if the
     *  selection for that date should be disabled.
     *
     */
    function (model) {
        var _this = this;
        if (this.selectFilter) {
            model.rows = model.rows.map((/**
             * @param {?} row
             * @return {?}
             */
            function (row) {
                row.cells.map((/**
                 * @param {?} dateButton
                 * @return {?}
                 */
                function (dateButton) {
                    /** @type {?} */
                    var disabled = !_this.selectFilter(dateButton, model.viewName);
                    dateButton.classes['dl-abdtp-disabled'] = disabled;
                    if (disabled) {
                        dateButton.classes['aria-disabled'] = true;
                    }
                    return dateButton;
                }));
                return row;
            }));
        }
        return model;
    };
    /**
     * Focuses the `.dl-abdtp-active` cell after the microtask queue is empty.
     * @internal
     **/
    /**
     * Focuses the `.dl-abdtp-active` cell after the microtask queue is empty.
     * \@internal
     *
     * @private
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.focusActiveCell = /**
     * Focuses the `.dl-abdtp-active` cell after the microtask queue is empty.
     * \@internal
     *
     * @private
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular((/**
         * @return {?}
         */
        function () {
            _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe((/**
             * @return {?}
             */
            function () {
                _this._elementRef.nativeElement.querySelector('.dl-abdtp-active').focus();
            }));
        }));
    };
    /**
     * Determines the start date for the picker.
     * @internal
     **/
    /**
     * Determines the start date for the picker.
     * \@internal
     *
     * @private
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.getStartDate = /**
     * Determines the start date for the picker.
     * \@internal
     *
     * @private
     * @return {?}
     */
    function () {
        if (hasValue(this._value)) {
            return this._dateAdapter.toMilliseconds(this._value);
        }
        if (hasValue(this.startDate)) {
            return this.startDate;
        }
        return moment$9().valueOf();
    };
    /**
     * Determine the start view for the picker
     * @returns
     *  the largest time increment view between the `minView` or `minute` view and the `startView` or `day` view.
     */
    /**
     * Determine the start view for the picker
     * @private
     * @return {?}
     *  the largest time increment view between the `minView` or `minute` view and the `startView` or `day` view.
     */
    DlDateTimePickerComponent.prototype.getStartView = /**
     * Determine the start view for the picker
     * @private
     * @return {?}
     *  the largest time increment view between the `minView` or `minute` view and the `startView` or `day` view.
     */
    function () {
        /** @type {?} */
        var startIndex = Math.max(VIEWS.indexOf(this.minView || 'minute'), VIEWS.indexOf(this.startView || 'day'));
        return VIEWS[startIndex];
    };
    /**
     * Calls all registered `touch` callback functions.
     * @internal
     **/
    /**
     * Calls all registered `touch` callback functions.
     * \@internal
     *
     * @private
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.onTouch = /**
     * Calls all registered `touch` callback functions.
     * \@internal
     *
     * @private
     * @return {?}
     */
    function () {
        this._touched.forEach((/**
         * @param {?} onTouched
         * @return {?}
         */
        function (onTouched) { return onTouched(); }));
    };
    /**
     * Receives configuration changes detected by Angular and passes the changes on
     * to the model providers so the provider is aware of any necessary configuration
     * changes (i.e. minuteStep)
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    /**
     * Receives configuration changes detected by Angular and passes the changes on
     * to the model providers so the provider is aware of any necessary configuration
     * changes (i.e. minuteStep)
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.ngOnChanges = /**
     * Receives configuration changes detected by Angular and passes the changes on
     * to the model providers so the provider is aware of any necessary configuration
     * changes (i.e. minuteStep)
     *
     * @param {?} changes
     *  the input changes detected by Angular.
     * @return {?}
     */
    function (changes) {
        var _this = this;
        Object.keys(this._viewToModelProvider)
            .map((/**
         * @param {?} key
         * @return {?}
         */
        function (key) { return _this._viewToModelProvider[key]; }))
            .forEach((/**
         * @param {?} provider
         * @return {?}
         */
        function (provider) { return provider.onChanges(changes); }));
        if (this._model) { // only update the model after ngOnInit has set it the first time.
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.activeDate, this.valueOf);
        }
    };
    /**
     * Sets the initial model.
     *
     * @internal
     **/
    /**
     * Sets the initial model.
     *
     * \@internal
     *
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.ngOnInit = /**
     * Sets the initial model.
     *
     * \@internal
     *
     * @return {?}
     */
    function () {
        this.model = this._viewToModelProvider[this.getStartView()].getModel(this.getStartDate(), this.valueOf);
    };
    /**
     * Handles click (and enter & space key down) events on the date elements.
     *
     * If the current view is the minimum view then the date value is selected
     * and the picker returns to the start view.
     *
     * Otherwise the picker displays the next view with the next
     * smallest time increment.
     *
     * @internal
     **/
    /**
     * Handles click (and enter & space key down) events on the date elements.
     *
     * If the current view is the minimum view then the date value is selected
     * and the picker returns to the start view.
     *
     * Otherwise the picker displays the next view with the next
     * smallest time increment.
     *
     * \@internal
     *
     * @param {?} dateButton
     * @return {?}
     */
    DlDateTimePickerComponent.prototype._onDateClick = /**
     * Handles click (and enter & space key down) events on the date elements.
     *
     * If the current view is the minimum view then the date value is selected
     * and the picker returns to the start view.
     *
     * Otherwise the picker displays the next view with the next
     * smallest time increment.
     *
     * \@internal
     *
     * @param {?} dateButton
     * @return {?}
     */
    function (dateButton) {
        if (dateButton.classes['dl-abdtp-disabled']) {
            return;
        }
        /** @type {?} */
        var nextView = this._nextView[this._model.viewName];
        if ((this.minView || 'minute') === this._model.viewName) {
            this.value = this._dateAdapter.fromMilliseconds(dateButton.value);
            nextView = this.startView;
        }
        this.model = this._viewToModelProvider[nextView].getModel(dateButton.value, this.valueOf);
        this.onTouch();
    };
    /**
     * Handles click (and enter & space key down) events on the left button.
     *
     * Changes the displayed time range of the picker to the previous time range.
     * For example, in year view, the previous decade is displayed.
     *
     * @internal
     **/
    /**
     * Handles click (and enter & space key down) events on the left button.
     *
     * Changes the displayed time range of the picker to the previous time range.
     * For example, in year view, the previous decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    DlDateTimePickerComponent.prototype._onLeftClick = /**
     * Handles click (and enter & space key down) events on the left button.
     *
     * Changes the displayed time range of the picker to the previous time range.
     * For example, in year view, the previous decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    function () {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.leftButton.value, this.valueOf);
        this.onTouch();
    };
    /**
     * Handles click (and enter & space key down) events on the up button.
     *
     * Changes the view of the picker to the next largest time increment.
     * For example, in day view, the next view displayed will be month view.
     *
     * @internal
     **/
    /**
     * Handles click (and enter & space key down) events on the up button.
     *
     * Changes the view of the picker to the next largest time increment.
     * For example, in day view, the next view displayed will be month view.
     *
     * \@internal
     *
     * @return {?}
     */
    DlDateTimePickerComponent.prototype._onUpClick = /**
     * Handles click (and enter & space key down) events on the up button.
     *
     * Changes the view of the picker to the next largest time increment.
     * For example, in day view, the next view displayed will be month view.
     *
     * \@internal
     *
     * @return {?}
     */
    function () {
        this.model = this._viewToModelProvider[this._previousView[this._model.viewName]].getModel(this._model.upButton.value, this.valueOf);
    };
    /**
     * Handles click (and enter & space key down) events on the right button.
     *
     * Changes the displayed time range of the picker to the next time range.
     * For example, in year view, the next decade is displayed.
     *
     * @internal
     **/
    /**
     * Handles click (and enter & space key down) events on the right button.
     *
     * Changes the displayed time range of the picker to the next time range.
     * For example, in year view, the next decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    DlDateTimePickerComponent.prototype._onRightClick = /**
     * Handles click (and enter & space key down) events on the right button.
     *
     * Changes the displayed time range of the picker to the next time range.
     * For example, in year view, the next decade is displayed.
     *
     * \@internal
     *
     * @return {?}
     */
    function () {
        this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.rightButton.value, this.valueOf);
        this.onTouch();
    };
    /**
     * Handles various key down events to move the `active date` around the calendar.
     *
     * @internal
     **/
    /**
     * Handles various key down events to move the `active date` around the calendar.
     *
     * \@internal
     *
     * @param {?} $event
     * @return {?}
     */
    DlDateTimePickerComponent.prototype._handleKeyDown = /**
     * Handles various key down events to move the `active date` around the calendar.
     *
     * \@internal
     *
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        /** @type {?} */
        var functionName = keyCodeToModelProviderMethod[$event.key];
        if (functionName) {
            /** @type {?} */
            var modelProvider = this._viewToModelProvider[this._model.viewName];
            this.model = modelProvider[functionName](this._model.activeDate, this.valueOf);
            this.focusActiveCell();
            // Prevent unexpected default actions such as form submission.
            $event.preventDefault();
        }
    };
    /**
     * Implements ControlValueAccessor.registerOnChange to register change listeners.
     * @internal
     **/
    /**
     * Implements ControlValueAccessor.registerOnChange to register change listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.registerOnChange = /**
     * Implements ControlValueAccessor.registerOnChange to register change listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._changed.push(fn);
    };
    /**
     * Implements ControlValueAccessor.registerOnTouched to register touch listeners.
     * @internal
     **/
    /**
     * Implements ControlValueAccessor.registerOnTouched to register touch listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.registerOnTouched = /**
     * Implements ControlValueAccessor.registerOnTouched to register touch listeners.
     * \@internal
     *
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this._touched.push(fn);
    };
    /**
     * Implements ControlValueAccessor.writeValue to store the value from the model.
     * @internal
     **/
    /**
     * Implements ControlValueAccessor.writeValue to store the value from the model.
     * \@internal
     *
     * @param {?} value
     * @return {?}
     */
    DlDateTimePickerComponent.prototype.writeValue = /**
     * Implements ControlValueAccessor.writeValue to store the value from the model.
     * \@internal
     *
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.value = value;
    };
    DlDateTimePickerComponent.decorators = [
        { type: Component, args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    preserveWhitespaces: false,
                    providers: [
                        {
                            provide: NG_VALUE_ACCESSOR,
                            useExisting: DlDateTimePickerComponent,
                            multi: true
                        }
                    ],
                    selector: 'dl-date-time-picker',
                    template: "<div class=\"text-center dl-abdtp-{{_model.viewName}}-view\" [attr.data-dl-abdtp-view]=\"_model.viewName\">\n  <div class=\"row align-items-center no-gutters\">\n    <button class=\"col dl-abdtp-left-button align-items-center\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.leftButton.ariaLabel\"\n            [attr.dl-abdtp-value]=\"_model.leftButton.value\"\n            [attr.title]=\"_model.leftButton.ariaLabel\"\n            (click)=\"_onLeftClick()\"\n    ><span class=\"left-icon\" [ngClass]=\"leftIconClass\"></span>\n    </button>\n\n    <div *ngIf=\"_model.viewName === (this.maxView || 'year'); then maxViewLabel else defaultViewLabel;\"></div>\n\n    <button class=\"col dl-abdtp-right-button\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.rightButton.ariaLabel\"\n            [attr.dl-abdtp-value]=\"_model.rightButton.value\"\n            [attr.title]=\"_model.rightButton.ariaLabel\"\n            (click)=\"_onRightClick()\"\n    ><span class=\"right-icon\" [ngClass]=\"rightIconClass\"></span>\n    </button>\n  </div>\n  <div (keydown)=\"_handleKeyDown($event)\">\n    <div *ngIf=\"_model.rowLabels?.length\" class=\"row no-gutters\">\n      <div *ngFor=\"let label of _model.rowLabels\"\n           class=\"col align-items-center no-gutters dl-abdtp-col-label\">{{label}}</div>\n    </div>\n    <div *ngFor=\"let row of _model.rows\" class=\"row align-items-center no-gutters\">\n      <div *ngFor=\"let cell of row.cells\"\n           role=\"gridcell\"\n           class=\"col dl-abdtp-date-button dl-abdtp-{{_model.viewName}}\"\n           [ngClass]=\"cell.classes\"\n           [attr.aria-label]=\"cell.ariaLabel\"\n           [attr.aria-disabled]=\"cell.classes['dl-abdtp-disabled']\"\n           [attr.dl-abdtp-value]=\"cell.value\"\n           [attr.tabindex]=\"cell.classes['dl-abdtp-active'] ? 0 : -1\"\n           (click)=\"_onDateClick(cell)\"\n           (keydown.space)=\"_onDateClick(cell)\"\n           (keydown.enter)=\"_onDateClick(cell)\"\n      >{{cell.display}}</div>\n    </div>\n  </div>\n</div>\n\n<ng-template #maxViewLabel>\n  <div class=\"col-10 dl-abdtp-view-label\">{{_model.viewLabel}}</div>\n</ng-template>\n<ng-template #defaultViewLabel>\n  <button class=\"col-10 dl-abdtp-view-label dl-abdtp-up-button\"\n          type=\"button\"\n          [attr.aria-label]=\"_model.upButton.ariaLabel\"\n          [attr.dl-abdtp-value]=\"_model.upButton.value\"\n          [attr.title]=\"_model.upButton.ariaLabel\"\n          (click)=\"_onUpClick()\"\n          [ngClass]=\"_model.upButton.classes\"\n  >{{_model.viewLabel}}&nbsp;<span class=\"up-icon\" [ngClass]=\"upIconClass\"></span>\n  </button>\n</ng-template>\n",
                    styles: [":host{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dl-abdtp-col-label,.dl-abdtp-view-label{font-weight:700}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-view-label{padding:5px;border-radius:999px;cursor:pointer;color:rgba(0,0,0,.87);outline:0}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-up-button{border-width:0}.dl-abdtp-active:focus,.dl-abdtp-date-button:focus,.dl-abdtp-date-button:hover,.dl-abdtp-left-button:focus,.dl-abdtp-left-button:hover,.dl-abdtp-right-button:focus,.dl-abdtp-right-button:hover,.dl-abdtp-up-button:focus,.dl-abdtp-up-button:hover,.dl-abdtp-view-label:focus{background:rgba(0,0,0,.04)}.dl-abdtp-future,.dl-abdtp-past{color:rgba(0,0,0,.04)}.dl-abdtp-now,.dl-abdtp-now.disabled,.dl-abdtp-now.disabled:hover,.dl-abdtp-now:hover{border-radius:999px;border:1px solid rgba(0,0,0,.25)}.dl-abdtp-selected{color:#fff;background:rgba(0,82,204,.75)}.dl-abdtp-selected:focus,.dl-abdtp-selected:hover{background:#0052cc}.dl-abdtp-disabled{cursor:default;color:rgba(0,0,0,.25)}"]
                }] }
    ];
    /** @nocollapse */
    DlDateTimePickerComponent.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone },
        { type: DlDateAdapter },
        { type: DlYearModelProvider },
        { type: DlMonthModelProvider },
        { type: DlDayModelProvider },
        { type: DlHourModelProvider },
        { type: DlMinuteModelProvider }
    ]; };
    DlDateTimePickerComponent.propDecorators = {
        change: [{ type: Output }],
        leftIconClass: [{ type: Input }],
        maxView: [{ type: Input }],
        minView: [{ type: Input }],
        minuteStep: [{ type: Input }],
        rightIconClass: [{ type: Input }],
        selectFilter: [{ type: Input }],
        startDate: [{ type: Input }],
        startView: [{ type: Input }],
        upIconClass: [{ type: Input }]
    };
    return DlDateTimePickerComponent;
}());
/**
 * \@internal
 * @param {?} value
 * @return {?}
 */
function hasValue(value) {
    return (typeof value !== 'undefined') && (value !== null);
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * Import this module to supply your own `DateAdapter` provider.
 * \@internal
 *
 */
var DlDateTimePickerModule = /** @class */ (function () {
    function DlDateTimePickerModule() {
    }
    DlDateTimePickerModule.decorators = [
        { type: NgModule, args: [{
                    declarations: [DlDateTimePickerComponent],
                    imports: [CommonModule],
                    exports: [DlDateTimePickerComponent],
                    providers: [
                        DlYearModelProvider,
                        DlMonthModelProvider,
                        DlDayModelProvider,
                        DlHourModelProvider,
                        DlMinuteModelProvider
                    ],
                },] }
    ];
    return DlDateTimePickerModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { DlDateAdapter, DlDateAdapterMoment, DlDateAdapterNative, DlDateAdapterNumber, DlDateAdapterString, DlDateTimeCoreModule, DlDateTimeNumberModule, DlDateTimeDateModule, DlDateTimeMomentModule, DlDateTimeStringModule, DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT, DL_DATE_TIME_INPUT_FORMATS, DL_DATE_TIME_INPUT_FORMATS_DEFAULT, DL_DATE_TIME_MODEL_FORMAT, DL_DATE_TIME_MODEL_FORMAT_DEFAULT, DlDateTimeInputChange, DlDateTimeInputDirective, DlDateTimeInputModule, DlDateTimePickerChange, DlDateTimePickerComponent, DlDateTimePickerModule, DlDayModelProvider, DlHourModelProvider, DlMinuteModelProvider, DlMonthModelProvider, DlYearModelProvider };

//# sourceMappingURL=angular-bootstrap-datetimepicker.js.map